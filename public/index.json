[
{
	"uri": "https://me.abyssaltech.xyz/notes/2019-01-22-c-programming-chapter-2/",
	"title": "Chapter 2 - Types, Operators, and Expressions",
	"tags": [],
	"description": "",
	"content": " Chapter 2 - Types, Operators, and Expressions Variables  The first haracter must be a letter. Underscore(_) is a letter. Library functions have variable names that start with an underescore. Uppercase and lowercase letters are distinct, X is not the same as x.  Data Type and Sizes    Data type Keyword Size (in Bytes) Range     Character char 1    Integer int 2 -32768 to +32767   Single-precision floating point float 4 10-38 to 10+38   Double-precision floating point double 8     Qualifiers can also be applied to these data types.\n signed and unsigned applies to int and char data types.  short int n; long int m; //the word int can be omitted - short n; long m;  A compiler is free to choose any size for these.\n RULE - short and int must be atleast 16 bits, long must be atleast 32 bits, and short must not be larger than int whch must not be larger than long.\n unsigned variables store zero and positive values only. signed stores both. Ex - if char is 8 bits, unsigned will store from 0 to 255 and signed from -128 to 127.\n  Constants  Integer constant - 1234 long - 123l or 123L or an integer too big to fit into int will be taken as long unsigned - 123u or 123U unsigned long - 123ul or 123UL Floating-point constant - 1234.0, their type is double unless suffixed with f/F (float) or l/L (long double) Octal - leading 0 on an integer - 012 Hexadecimal - leading 0x on an integer - 0x12  Octal and Hex constants may be followed by U or L suffix to make them unsigned or long respectively. 0xFUL // this is a unsigned long hex with value 15 in decimal   Character constant - written within single quotes. Ex - \u0026lsquo;A\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, etc\u0026hellip;  '\\0' has an ASCII value of 0. '0' has an ASCII value of 48 which is unrelated to zero.   Escape Sequences  '\\013' - Octal Number '\\xAF' - Hex Number     Escape Sequence Function     \\n Newline character   \\t Horizontal tab character   \\v Vertical tab character   \\b Backspace character   \\f Formfeed   \\a Alert (bell) character   \\r Carrige return   \\\u0026rsquo; Single quote   \\\u0026rdquo; Double quotes   \\\\ Backslash itself   \\? Question mark   \\0oo Octal number   \\xhh Hex number    A character constant 'a' is not the same as \u0026quot;a\u0026quot;, the former has an integer value internally and the latter is delimited by a null character ('\\0') character.  Constant Expression - #define MAX int p = MAX + 1; //These are evaluated at the compile-time.   Enumeration Constant - An enumeration is a list of constant integer values.  #include\u0026lt;stdio.h\u0026gt; int main() { enum my {hs, ho}; //By default, first name in an enum has value = 0, second one has value = 1 and so on... printf(\u0026quot;%d\\t\u0026quot;, he); printf(\u0026quot;%d\u0026quot;, ho); return 0; } OUTPUT: 0 1  If not all values are specified, unspecified values continue the progression from the last specified value.\n#include\u0026lt;stdio.h\u0026gt; int main() { enum my {JAN = 23, FEB, MAR, APR, MAY}; printf(\u0026quot;%d\\t\u0026quot;, JAN); printf(\u0026quot;%d\\t\u0026quot;, FEB); printf(\u0026quot;%d\\t\u0026quot;, MAR); printf(\u0026quot;%d\\t\u0026quot;, APR); printf(\u0026quot;%d\\t\u0026quot;, MAY); return 0; } OUTPUT: 23 23 25 26 27  Names in an enumeration must be distinct, values may not be so.\nDeclarations  Global/External and static variables are initialized to 0 by default. Local/Automatic variables for which there is no initializer have undefined (i.e. garbage) values. const - It is used to indicate that the variable\u0026rsquo;s value cannot be changed now.  const int p = 5; //OR int func(const ch[]); //ch's values cannot be changed by func()  Operators Arithmetic Operators    Binary Arithmetic Operators Unary Arithmetic Operators     + +   - -   *    /    %      % operator cannot be applied to float or double.  Relational Operators    Relational Operators     \u0026gt;   \u0026lt;   \u0026gt;=   \u0026lt;=   ==   !=     Relational operators have lower precendence than arithmetic oprators. So, i \u0026lt; lim-1 is taken as i \u0026lt; (lim-1). Precedence of != is higher than assignment =.  Logical Operators    Logical Operators     !   \u0026amp;\u0026amp;   ||     Evaluated from left to right.  if(!valid) //if not valid //OR if(valid == 0) //if valid is false  Type Conversions When taking place implicitly, \u0026ldquo;narrower\u0026rdquo; type to a \u0026ldquo;wider\u0026rdquo; type is done. Ex - float to int.\n Can a char when resolved to an integer be negative?  No, C guarantees that any character is not negative. Yet, some arbitrary bit pattern stored in character variables may appear to be negative on some machines, yet positive on others. For portability, specify signed or unsigned if non-character data is to be stored in char variables.  If tere are no unsigned oprands involved, and either oprand is long, float, double, or long double, other is converted to the same type. And short and char are converted to int. When unsigned operands are involved comparison between signed and unsigned operands is machine-dependent.  Cast Operators - (type-name) expression Ex - (float) 4/2; (unsigned int) 4.3 - 2;  Increment and Decrement Operators  i++ is equivalent to i = i + 1, and i-- is quivalent to i = i - 1. Prefix - ++i and Postfix - i++. ++i increments the value of i and then uses it, and i++ increments the value before using it. They can only be applied to variables. An expression like (i + j)++ is illegal. In a context where no value is stored, prefix and postfix are the same. Ex - when used as loop counters.  Bitwise Operators    Bitwise Operators     \u0026amp;   |   ^   \u0026lt;\u0026lt;   \u0026gt;\u0026gt;   ~     Left Shifting  x \u0026lt;\u0026lt; 2 //shifts left by two positions (equivalent to multiplying by 4)   Right Shifting  Right shifting an unsigned bit fills vacated bits with 0-bits. Right shifting a signed bit fills vacated bits with sign bit \u0026ldquo;arithmetic shift\u0026rdquo;, or with 0-bits \u0026ldquo;logical shift\u0026rdquo;.   #include\u0026lt;stdio.h\u0026gt; int main() { int p = 3; printf(\u0026quot;%d\\n\u0026quot;, ~p); return 0; } OUTPUT: -4  Assignment Operators and Expressions i = i + 2; //can be written as i += 2; //+= is an assignment operator   In assignment operation the type is the same as the left side operand.  #include\u0026lt;stdio.h\u0026gt; int main() { char p = 'a'; int x; p += x; printf(\u0026quot;%d\\n\u0026quot;, sizeof(p)); return 0; } OUTPUT: 1  Conditional Expressions a \u0026gt; b? max=a : max=b; //can also be written as - max = a \u0026gt; b? a : b;  IMPORTANT NOTE - The conditional expression is indeed and expression. Type conversion rules apply here.\n// assume f is float and n is int (n \u0026gt; 0)? f : n; //result will be float no matter if the condition is true or not.  Precedence and Order of Evaluation  The precedence of Bitwise operators is below == and != operators.  //Be careful in - if((x \u0026amp; MASK) == 0) ...   C does not specify the order in which the operands of an operator are evaluated.  x = f() + g(); //not sure which ammong f() or g() is evaluated first //AND printf(\u0026quot;%sd %d\\n\u0026quot;, ++n, power(2, n)); //Different compiler, different results, based on what is evaluated first   Don\u0026rsquo;t write any code that depends upon the order of evaluation. They are not covered in the standard.  a[i] = i++; //Subscript is the old value of i or new? //Ans - Compilers can interpret it in different ways and generate different answers based on the interpretation.  "
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2019-01-22-c-programming-chapter-3/",
	"title": "Chapter 3 - Control Flow",
	"tags": [],
	"description": "",
	"content": " Chapter 3 - Control Flow Statements and Blocks  An expression like i+2, i++, or printf(...) terminated by a ; becomes a statement in C. Braces { and } are used to group statements inside a compound statement or a block.  If-Else  In if-else the else part is optional. if checks the numeric value of an expression after evaluating it.  We might do -\nif(x) //non-zero value implicitly means true //instead of if(x != 0)  Else-if  Multiple cases can be made using else-if. Additional case/error catching case can be a last else but it is optional.  Switch switch(expression) { case const-expr: statements case const-expr: statements default: statements }   Each case is labeled by integer-valued constants or constant expressions. All cases must be different. default case is optional.\n IMPORTANT NOTE - Switch is fall through i.e. if we do not break the flow after a case, then it goes to the next case until it is stopped explicitly.\n Several cases can be attached to a single action using this fall through property.\n  #include\u0026lt;stdio.h\u0026gt; int main() { char sec; scanf(\u0026quot;%s\u0026quot;, \u0026amp;sec); switch (sec) { case 'a': case 'A': case 'b': case 'B': case 'c': case 'C': printf(\u0026quot;Your class has 10 students.\u0026quot;); break; case 'd': case 'D': case 'e': case 'E': printf(\u0026quot;Your class has 11 students.\u0026quot;); break; default: printf(\u0026quot;Section not found.\u0026quot;); break; } return 0; }  Loops - While and For  for and while loops are basically the same thing. All three - Initialization, Condition, and Update in a for loop are expressions and either of them can be omitted, but the semicolons must remain. Without the condition, for loop is infinite, even if we do not update. Multiple expression separated by comma are allowed in for loop.  for (int i = 0, j = 1; i \u0026lt; counti, j \u0026lt; countj; i++, j++) { /* code */ }  Do-while  The condition check is at last so the body is executed atleast once. Braces around a single statement inside do block is optional but the while part can be mistaken for start of a while loop.  Break and Continue  break causes an exit from the innermost enclosing loop or switch. continue causes the next iteration of the loop to begin. A continue has no meaning in switch. IMPORTANT NOTE - A continue inside a switch inside a loop will cause the loop to jump to next iteration.  Goto and Labels  goto can jump to a label anywhere inside the same function. A label follows same naming conventions as that of variables.   "
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2019-01-22-c-programming-chapter-4/",
	"title": "Chapter 4 - Functions and Program Structure",
	"tags": [],
	"description": "",
	"content": " Chapter 4 - Functions and Program Structure  Advantages of using Functions -  Large computing tasks can be separated into smaller ones, so long as no function is split. Abstraction Easing the pain of making chanfges to code Source program can be stored across multiple files Code reusability   Basics of Functions return-type function-name(argument declarations) { declarations and statements //body }   If the return type is omitted during function declaration, it is assumed to be int. To return a value to the caller return is used.  return expression; //expression can be converted to the return type of the function if necessary   A function can return a \u0026ldquo;garbage value\u0026rdquo; or no value.  Functions Returning Non-integers double func(char arr[]) //return type is double { //body return sign; } //we can declare it in main() which is optional main() { double func(arr[]); //same type here, otherwise meaningless answers }  double func(char arr[]) //return type is double { int sign; //body return sign; //sign will be converted to double when returning value }   Statements following a return have no significance and are useless.\n If a function uses no arguments, use void. Don\u0026rsquo;t leave it blank as parameter checking is turned off then and it is still there just for backwards compatibility.\n  int func(void) {...}  External Variables  Variables \u0026ldquo;external\u0026rdquo; to any function a.k.a global variables. References to them are same no matter from where we\u0026rsquo;re accessing them. They have a scope that lasts for the lifetime of the whole program unlike automatic variables. No function can be defined inside any other function in C.  Scope Rules  Automatic variables have a scope that is limited to the function in which they are declared. External variables have program scope. Declaration announces the properties of a variable while a Definition also causes storage to be set aside.  Same program in different files:\nfile1 - extern int p; //declared wherever required extern float q; file2 - int p; //external variables are defined only once float q;  Header Files  After we divide the program into separate source files and using external variables from another file, we can store this file that contains external variables as a header file with an extension .h.  Each file that needs the calc.h header file has #include \u0026quot;calc.h\u0026quot; in the beginning as preprocessor directive.\n There is a tradeoff bwetween the desire that each file have access only to the information it needs for its job and the practical reality thaat it is harder to maintain more header files. Upto moderate program size, we should try to keep one header file.  Static Variables  Static variables are specified by specifier static They are external variables that can only be accessed by the functions inside the same file and not by other functions not in the same file but are of the same program. Hence the names will also not conflict with other variables in differrent files.  static char buf[BUFSIZE]; static int bufp = 0; int getch(void) { ... } void ungetch(int c) { ... }   static can also be used for functions. the functions declared static will be invisible to the functions in the other files of the same program. static can also be used for local variables and are invisible to other functions but they remain (retain value) there even when we enter and leave functions unlike automatic variables which are initialized everytime we call their parent function.  ###\n"
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2019-01-21-c-programming-dennis-ritchie/",
	"title": "C Programming",
	"tags": [],
	"description": "",
	"content": "Preface \u0026amp; Chapter 1: A Tutorial Introduction\nChapter 2: Types, Operators, and Expressions\nChapter 3: Control Flow\nChapter 4: Functions and Program Structure\n"
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2019-01-21-c-programming-chapter-1/",
	"title": "Preface &amp; Chapter 1 - A Tutorial Introduction",
	"tags": [],
	"description": "",
	"content": " Preface What C gets right.  C is a general-purpose programming language. It is not a very high level language, nor a big one. It was originally designed for and implemented on the UNIX operating system. Very useful for writing operating system, compilers and system programs and hence it is also called a \u0026ldquo;systems programming language\u0026rdquo;. Many important ideas in C stem from BCPL and B. [BCPL -\u0026gt; B -\u0026gt; C] BCPL and B are \u0026ldquo;typeless\u0026rdquo; languages, they don\u0026rsquo;t have data types defined. On the other hand, C provides a variety of data types, as well as a hierarchy of derived data types like structure and union. Expressions are statements in C. Pointers provide machine-independent address arithmetic. Control flow constructions - for, while, if-else, etc. Functions in C might be in separate source files that can be compiled separately. Concept of Local(Automatic) and Global variables. Preprocessing to include libraries and to perform macro expansion.  Some Features of C  C provides no input/output facilities(READ or WRITE). C provides no operation to deal directly with composite objects such as strings and arrays. No storage allocation other than static definition and stack discipline provided by local variables of functions. There is no heap and garbage collection. C offers only straightforward, single-thread control flow: tests, loops, etc., but no parallel operation, multiprogramming, sync, or coroutines. C Programming language was standardized by ANSI (American National Standards Institute) in 1988. ANSI C also included definition of a library to accompany C. It specifies functions for accessing the operating system (Read/Write), formatted input and output, memory allocation, string manipulation, etc. This library is closely modeled on the \u0026ldquo;standard I/O library\u0026rdquo; of the UNIX system.  Chapter 1: A Tutorial Introduction  main() - The program begins executing at the beginning of main and there must be atleast one in the program. \u0026quot;Hello, world\u0026quot; - a sequence of characters in double quotes is called a string constant or character string or string literal.\n /*.....*/ - Multi-line comment.\n  The above sizes are machine-dependent.\n Storing foating point number in int truncates it (i.e. strores only the integer part).\n In the below code, % followed by character indicates where the arguments are to be substituted.\n  printf(\u0026quot;%d \\n\u0026quot;, num); //integer printf(\u0026quot;%ld \\n\u0026quot;, num); //long integer printf(\u0026quot;%f \\n\u0026quot;, num); //float, double printf(\u0026quot;%c \\n\u0026quot;, fname); //char printf(\u0026quot;%s \\n\u0026quot;, fname); //string printf(\u0026quot;%o \\n\u0026quot;, num); //octal printf(\u0026quot;%x \\n\u0026quot;, num); //hexadecimal printf(\u0026quot;%% \\n\u0026quot;, num); //for % itself   A decimal point in a constant indicates that it is a floating point e.g. 5 is integer, 5.0 is float.  printf(\u0026quot;%d \\n\u0026quot;, num); // integer has 6 digits width printf(\u0026quot;%f \\n\u0026quot;, num); // integer has 6 digits width printf(\u0026quot;%6d \\n\u0026quot;, ); // integer has 6 digits width printf(\u0026quot;%.3f\\n\u0026quot;, ); // float can have any width integer part but decimal part has a limit of 3 digits printf(\u0026quot;%.0f\\n\u0026quot;, ); //supresses printing of the decimal point and the fractional part printf(\u0026quot;%3.2f\\n\u0026quot;, ); // atleast 3 wide, 2 after decimal point  The width in the integer part does not actually play a part as evident from below.\n#include\u0026lt;stdio.h\u0026gt; int main() { float n = 656.56789; int m = 251; printf(\u0026quot;%2.3f\\n\u0026quot;, n); printf(\u0026quot;%2d\\n\u0026quot;, m); printf(\u0026quot;%.0f\\n\u0026quot;, n); return 0; } Output: 656.568 //rounded off to only 3 decimal places 251 //no effect 657 //whole decimal part rounded off with no digit left after decimal   Symbolic Constants  #define name replacement-text\n#define LOWER 0 #define UPPER 300 #define STEP 20 // We can now proceed to use the above defined constants throughout the program as it is. // They are written in uppercase to distinguish them from variables.   Character input and output - getchar() and putchar() - Standard library provides them to read/write just one character at a time.  c = getchar(); //reads the next character from text stream and return its value putchar(c); //prints a character each time it is called   End Of File (EOF) - EOF is just a symbolic constant stored in  with some integer value that we don\u0026rsquo;t need to know. Whenever a file ends it returns a value that cannot be confused with any character\u0026rsquo;s integer value, that value is EOF.\n Precedence of != is higher than =.\n Expressions can be evaluated inside the loop condition.\n  #include\u0026lt;stdio.h\u0026gt; main(){ int c; while((c = getchar()) != EOF) //getchar() call is perfectly fine here putchar(c); }   Assignment  nl = nw = nc = 0; //above expression is evaluated as follows (nl = (nw = (nc = 0)));   Functions - Declaration (Prototype), Definition, Call.  int func(int n, int m); //Declaration or int func(int , int); //also valid  int func(int n, int m) //formal paramters (parameters) { //function statements return expression; //zero implies normal termination, otherwise unusual or errorneous termination } main() { func(x,y); //actual parameters (arguments) }   Functions are always CALLED BY VALUE in C. We can be assured that the variables are always local to a called routine.\n Character arrays are called Strings, they are terminated by a '\\0' character which may not be the part of our actual string but is very much a part of the character array. Besides this they work just like an integer array.\n  char str[4] = \u0026quot;abhi\u0026quot;; //this will lead to error that the string is too long beacuse we need one element (last element) of a character array for '\\0' character   External Variables and Scope - Local variables are called automatic variables because they are used automatically whenever we\u0026rsquo;re inside the scope/function. Global variables are called external variables and they must be defined exactly once outside any functions.  When using external variables before even defining them in the souce file we might have to declare them using - extern keyword.\nint foo() { extern int num; //other statements } int num = 2; //external variable main() { foo(); }  Note that the external variables are also there when we don\u0026rsquo;t need them, so we must avoid using them too much.\n"
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-10-23-todo/",
	"title": "Todo",
	"tags": [],
	"description": "",
	"content": " Migrate to Learn Theme. Link - https://github.com/matcornic/hugo-theme-learn Demo - https://learn.netlify.com/en/ "
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-18-const/",
	"title": "Const",
	"tags": [],
	"description": "",
	"content": " Constant Data Members Data Members declared with cont keyword cannot be re-initialised. They must be initialized once. They can be declared once and initialised once.\nconst int x; // Declaration x = 90; // Initialisation  Initialisation List Any const data member must be initialised in Initialisation List.\nCar():name(NULL), year(1991) { } Car(int price, int m):price(p), model(m) // Memory allocated to variables before entering the body of the constructor { }  Constant Functions Those functions that do not update data members of a class. They are basically there to identify themselves that they do not update any data members, so no need to debug them for data member related bugs.\nvoid start() const { // Body }  Constant Parameter To declare a parameter as a constant for a function, they remain constant for that function throughout its scope.\nvoid print(const int n, char name) { // Body } // n cannot be changed throughout the scope of the print() function.  "
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-18-constructors-destructors/",
	"title": "Constructors and Destructors",
	"tags": [],
	"description": "",
	"content": " Constructors Every class comes with four hidden functions. 1. Default Constructor 2. Parameterized Constructor 3. Copy Constructors 4. Destructor\nDefault Constructors  They have the same name as the class and do not have any return type. They are provided implicitly and they initialise with 0.\nclass me { me() { // they have nothing inside } }  Parameterized Constructors  If we write something inside and parameterize it, then it is called parameterized constructor.\nclass me { public: int marks; int age; me(int m, int a) // Constructor with parameters { marks = m; // Putting in values age = a; } void print() { cout \u0026lt;\u0026lt; marks \u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt; age; } }; int main() { me t(99, 19); // parameterized constructor call t.print(); }  Copy Constructors It is used to create a copy of given object of the same type.\nIt exists by default and we don\u0026rsquo;t need to create it explicitly.\n class me { public: int marks; int age; me() { // Default Constructor } me(int m, int a) // Parameterized Constructor { marks = m; // Putting in values age = a; } me(me \u0026amp;x) // Copy Constructor (parameter is another object from where to copy which is PASSED BY REFERENCE) { marks = x.marks; age = x.age; } void print() { cout \u0026lt;\u0026lt; marks \u0026lt;\u0026lt;\u0026quot; \u0026quot;; cout\u0026lt;\u0026lt; age; } }; int main() { me t(99, 19); // Parameterized Constructor call t.print(); me m1(t); // Copy Constructor Call [create object m1 and, copy object t's values in object m1] me m1 = t; // Alternate Call Syntax for Copy Constructor m1.print(); }  Shallow Copy and Deep Copy We don not need to assign the same array memory every time for our need, say, name. We can have char name[40] and store names in it, but sometimes names are shorter than 40 and a lot of space is wasted because for every name array is allocated.\nSolution - We can allocate space to array on demand, dynamically from the Heap.\nWhen pointers are copied from one object to another using Default Copy Constructor the address in the pointer remains the same and changes done to one will be reflected into the others too. This is a Shallow Copy.\nHence we need to dynamically allocate new pointers in our new object and copy data manually in our Copy Constructor to avoid this. This is a DeepCopy.\n#define LABEL(x, val) cout \u0026lt;\u0026lt; \u0026quot;Updated Value of \u0026quot; \u0026lt;\u0026lt; (#x) \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; (val)\\ \u0026lt;\u0026lt; endl class Person{ int age; public: char* name; Person(int k, const char n[]){ age = k; int len = strlen(n); name = new char[len]; // dynamic allocation strcpy(name, n); } void print(){ cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot;:\u0026quot; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; } }; int main(){ Person P1(20, \u0026quot;Johnny\u0026quot;); P1.print(); // Johnny : 20 Person P2 = P1; // Person P2(P1); P2.initialiseWith(P1) P2.print(); //Johnny : 20 P2.name[0] = 'T'; LABEL(P2, P2.name); // Tohnny LABEL(P1, P1.name); // Tohnny // Shallow Copy }  Shallow Copy happened because the we copied pointer to array from P1 to P2, and when we changed in P2, changes were reflected in P1 too.\n With default copy constructor only a Shallow Copy is created.\n We can explicitly create copy constructor to create a Deep Copy.\n  To create a deep copy just create a new array for P2 using explicitly supplied copy constructor.\nPerson(const Person\u0026amp; p){ // Explicit Copy Constructor age = p.age; name = new char[strlen(p.name)]; // Deep Copy created strcpy(name, p.name); // Array copied } int main(){ Person P1(20, \u0026quot;Johnny\u0026quot;); P1.print(); // Johnny : 20 Person P2 = P1; // Person P2(P1); P2.initialiseWith(P1) P2.print(); //Johnny : 20 P2.name[0] = 'T'; LABEL(P2, P2.name); // Tohnny LABEL(P1, P1.name); // Johnny }  Copy Asignment Operator We can assign values from one constructor to another. It can called many times, unlike copy Constructor which is called only once when creating an object.\nCar c; Car d; d = c; d = e; d = r; // Copy Assignment Constructor  Beware - Copy Assignment Constructor creates shallow copy, do not use it if you have any pointers among data members.\nDestructors Default Destructor - Destroys created objects as soon as the program [main() function] goes out of scope implicitly. It does not deletes dynamically allocated data members, for them we have to manually delete them using delete ptr. - Same name as class name preceded by a tilde ~. - Do not return anything and do not take any parameters. - We only need to write it for deleting dynamically allocated data members. - When a class contains a pointer to memory allocated in class, we should write a destructor to release memory before the class instance is destroyed. This must be done to avoid memory leak.\nCar() { cout \u0026lt;\u0026lt; \u0026quot;Deleting...\u0026quot;; delete [] name; // Deleting 'name' array } int main() { Car *DC = new Car(1991, \u0026quot;Audi\u0026quot;); // Dynamic Object will not be destroyed by default destructor delete DC; }  "
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-18-oops-in-c++/",
	"title": "Object-Oriented Programming in C++",
	"tags": [],
	"description": "",
	"content": " Goals Everything in the real-world has a name and a functionality associated with it. Ex - A name of an object is \u0026ldquo;Dog\u0026rdquo;, it can have various parameters like breed, length, height, or the functions it can perform like running, eating, sleeping.\nWhat we can do is that we can create objects of a Dog and then whenever we want to store different information about any Dog, we can use that object again and again.\nEverything that has an independent existence in real-life is called an Object, it can also be called as an Instance of a class.\nA Class is the blueprint for an object that tells the compiler how and what our object and its properties and functions are.\n// Define Blueprint class Car { public: int price; int model_no;\t// Data Member bool isRunning();\t// Function }; int main() { Car c;\t// To create object just like we declare a variable of a type cout \u0026lt;\u0026lt; sizeof(c); // c is an object of 8 bytes cout \u0026lt;\u0026lt; sizeof(Car); // 8 bytes because sizeof() returns size of the object when it'll be created // A class is just a piece of code and is nothing without its object Car R[100]; // Array of Cars }  The properties (variables) like name and size are called as Data Members.\nint num; char name[20];  The functions and tasks associated are called Functions.\nint nRotations(); bool isRunning();  Dot(.) Operator Used to access Data Members and Functions.\nCar c; c.name = \u0026quot;BMW\u0026quot;; c.model_no = 1991; c.isRunning();  Access Modifiers  private - By Default C++ has all data members and functions as Private. They cannot be accessed by functions not part of the class. public - They can be accessed anywhere.  class Pen { public: string name; string colour; }  protected  Getters and Setters Getters are used to get the value of a data member.\nSetters are used to set the value of a data member.\nclass Car { string name; }; int main() { Car c; c.name=\u0026quot;Audi\u0026quot;; // directly accessing a private data member not allowed }  We can use getters and setters to access and modify private data members as shown below.\nclass Car { private: int year; public: void setYear(int y)\t// Setter Function { year=y; } int getYear()\t// Getter Function { return year; } }; int main() { Car c; c.setYear(2006);\t// Setter Function Call cout \u0026lt;\u0026lt; c.getYear();\t// Getter Function Call }  Memory allocation Every Object and Data Member gets allocated a space, but Functions have a common memory across all objects.\n"
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-18-vectors-and-generic/",
	"title": "STL - Vectors and Generic Programming",
	"tags": [],
	"description": "",
	"content": " Vectors They are data structures in C++ just like arrays but they have size that is capped only by the amount of space we can possibly allocate.\n Header files:  #include\u0026lt;vector\u0026gt;  Declaration:  vector\u0026lt;int\u0026gt; v; // vector\u0026lt;data_type\u0026gt; name;  As Function Parameter Passed by Reference:  int func(int n, vector\u0026lt;int\u0026gt; \u0026amp;v) { }   Built in Functions  v.push_back(x) - Pushes the element(x) inside the vector. v.pop_back(x) - Pops the element(x) from the vector. v.reserve(100) - Reserves a vector space of 100. v.size() - Returns size of the vector.  For more functions, refer here.\nGeneric Programming in C++  Placeholders in templates get replaced by a data type.  Generic Data Types and Function Templates To declare a generic data type.\ntemplate\u0026lt;typename T\u0026gt; or template\u0026lt;class T\u0026gt;   Usage:  #include\u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; T bigger(T a, T b) // Generic Function with a generic Return Type { if(a \u0026gt; b) return a; else return b; } int main() { cout \u0026lt;\u0026lt; bigger(14.2,7.2); } OUTPUT : 14.2   With Multiple Placeholders:  #include\u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;typename X, typename Y\u0026gt; Y bigger(X a, Y b) // Generic Function with a generic Return Type (X) { if(a \u0026gt; b) return a; else return b; } int main() { cout \u0026lt;\u0026lt; bigger(14.2,7); } OUTPUT : 14  We can also use the below syntax:\ntemplate\u0026lt;typename T\u0026gt; class Vector{ T arr[100]; } class Me{ int roll_no; char name[10]; } int main(){ Vector\u0026lt;int\u0026gt; v1; // Associating Constructor of Class Vector and type int and Making the whole as another object (v1) Vector\u0026lt;Me\u0026gt; v2; // Associating another class object (type) and making the whole as an object (v2) char arr_char[] = {'a','b','c'}; print\u0026lt;char\u0026gt;(arr_char, 3); print\u0026lt;char\u0026gt;(arr_char, 3, compareInt); // Function call for a specific data type specified by [function_name\u0026lt;data_type\u0026gt;(para,meter,s)] }  Let\u0026rsquo;s see another example -\nclass Elephant{ public: int wt; char name[20]; }; template\u0026lt;typename T, typename Y \u0026gt; void print(T arr[], int n, Y printCriteria){ // Y is a function type for(int i = 0; i \u0026lt; n; ++i){ printCriteria(arr[i]); // printMyElephant(arr[i]) } cout \u0026lt;\u0026lt; endl; } void printMyElephant(Elephant E){ cout \u0026lt;\u0026lt; E.wt \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; E.name \u0026lt;\u0026lt; endl; } int main(){ Elephant E[] = { // Array of objects {1600, \u0026quot;Hachi\u0026quot;}, {1500, \u0026quot;Rocky\u0026quot;}, {1000, \u0026quot;Jumbo\u0026quot;} }; print(E, 3, printMyElephant); // Passed whole function }  In the above example we created a function for comparing Elephants. Since our compiler didn\u0026rsquo;t know how to print Elephants, we passed that function to our generic function to print any values adding another parameter for it and the value in print() got bounded during compile-time to printMyElephant() that we passed in our call.\nClass Templates Since we can also pass into out Generic type the objects of class. We have to be careful as the algorithms that work flawlessly for data types might not work for an object. Ex - How do you compare two objects? What is the result of this? - Car c \u0026gt; Pen p;.\nWe need to build a Generic system that frees our algorithm from implementation and truly make us achieve generic nature across all types.\nclass VectorInt{ int arr[100]; }; class VectorChar{ char arr[100]; }; template \u0026lt;typename T\u0026gt; class Vector{ // Generic Class T arr[100]; // Array has elements of type T }; class Elephant{ int wt; char name[100]; }; int main(){ // VectorInt vint; // container of ints (object) // VectorChar vchar; // container of chars (object) Vector\u0026lt;int\u0026gt; v1; Vector\u0026lt;char\u0026gt; v2; Vector\u0026lt;Elephant\u0026gt; v3; // Vector containing Elephant data type }  More here.\n"
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-10-bitwise-and-recursion/",
	"title": "Bitwise Operations and Recursion",
	"tags": [],
	"description": "",
	"content": " BITWISE Operator \u0026gt;\u0026gt; Right Shift Operator - results in 2^(number of times shifted) \u0026lt;\u0026lt; Left Shift Operator   Bitwise AND (\u0026amp;) yields an integer value. Bitwise OR (|) yields an integer value. Bitwise XOR (^) yields either 0 or 1. To identify if the last bit is SET(=1), AND(\u0026amp;) the number with 1.  Recursion int factorial(int n){ if(n==0) // Base Case { return 1; } int smallFact = factorial(n-1); // Recurrence Relation Fact = smallFact * n; return Fact; }  "
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-09-pointers/",
	"title": "Pointers",
	"tags": [],
	"description": "",
	"content": " Address  There exists one more data type called as \u0026ldquo;Address Data Type\u0026rdquo; which is used to store data. It has certain limitations in arithmetic operations that can be done with it and it is often represented as a Hex value. It behaves much like a real-world address. Address of anything is basically its starting address location (address). e.g. Arrays, etc\u0026hellip;  Meaning and Syntax  int *ptr = \u0026amp;x; - This statement creates a variable named \u0026ldquo;ptr\u0026rdquo; that stores address (data type) of the integer variable \u0026lsquo;x\u0026rsquo; - ptr is also called a Pointer. The * operator is called a value at operator, and another operator \u0026amp; is called address of operator. The above statement is same as writing - int *ptr = \u0026amp;x; x here can contain any value e.g. x = 20; We refer to the address ptr and value at ptr by *ptr. There are two ways to define pointers, pick one ans follow throughout your program.  int* ptr = x; // Asterisk with data-type int *ptr = y; // Asterisk with pointer name   int *ptr = x; or int *ptr = 10; will lead to compile-time error because we\u0026rsquo;re trying to assign integer value to a pointer data type.  #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int x = 10; int* ptr = \u0026amp;x; cout \u0026lt;\u0026lt; ptr; // will print address of x cout \u0026lt;\u0026lt; *ptr; // will print 10 }   DO NOT declare pointers (create pointers and leave them without initializing them). int *ptr; Doing this will lead to undefined behaviour as a garbage address value will be assigned to ptr and if it does not lie in our program\u0026rsquo;s allloted address space then the program will crash (Segmentation Fault). Segmentation Fault - Whenever we try to access an invalid or unavailable location. Contexts of the * symbol -  Declaration - int *ptr = \u0026amp;x; Dereferencing - int *ptr = \u0026amp;x; Multiplication - x * y  Only 0 or NULL can be typed as address for a pointer initialization.  Size of a Pointer A pointer is just another variable storing the address of others, so no matter what datatype it is pointing to, they are of same size - ALWAYS.\nPointer Arithmetic  Addition and Multiplication - Pointer addition is not valid as the result of the addition is an address that may or may not be valid (Implementation Defined). Division and Modulo - Not valid. Subtraction - ptr2 - ptr1 yields a result specifying how many elements can be accomodated between ptr2 and ptr1, hence only pointers of same data type can be substracted. Pointer added with and integer - ptr + 10 yields a result that is 10 elements further from the given address (initial value of ptr).  Pointers and Arrays  int arr[5] = {10, 20, 30, 40, 50}; cout \u0026lt;\u0026lt; arr; // arr is address of array, first element address, note that how only the name is enough cout \u0026lt;\u0026lt; \u0026amp;arr[0]; // address of the first element of array cout \u0026lt;\u0026lt; \u0026amp;arr; // arr is address of ARRAY cout \u0026lt;\u0026lt; arr[0]; // arr[0] cout \u0026lt;\u0026lt; (\u0026amp;arr[3]) - (\u0026amp;arr[0]); // 2 = (Starting address of 3rd element - Starting address of 0th element) cout \u0026lt;\u0026lt; \u0026amp;arr[3] - \u0026amp;arr[1]; // 1  When refering to the array with its name only e.g. Arya insted of Arya[], we are implying that we want address of the array, which is nothing but the address of the first element itself. If we do cout \u0026lt;\u0026lt; Arya;, we\u0026rsquo;ll get the address value equal to cout \u0026lt;\u0026lt; Arya[0].\nPointers and Character Arrays  char carr[5] = \u0026quot;abcd\u0026quot;; cout \u0026lt;\u0026lt; carr; // abcd, will print everything from given address to '\\0' cout \u0026lt;\u0026lt; \u0026amp;carr[2]; // c d cout \u0026lt;\u0026lt; carr[2]; // c cout \u0026lt;\u0026lt; (int*)\u0026amp;carr[2]; // some address of carr[2] cout \u0026lt;\u0026lt; \u0026amp;carr[3] - \u0026amp;carr[1]; // 2  NOTICE - cout in case \u0026amp;carr[2] that the output is c d, this is because cout\u0026lt;\u0026lt; is designed such that is prints values at addresses fed to it until a '\\0' is encountered. In print((int*)\u0026amp;carr[2]) the address get typecasted to a pointer type and hence converts to the address of the second element of the character array.\nPointers and Functions In the below code, the two function definitions are exactly the same, as implicitly, only a pointer to the array is passed to the function definition as they are always passed by reference.\nint func2(int* arr){ } int func1(int arr[]){ }  Pointer Arrays int (*ptr)[10] represents a pointer array of size 10.\n"
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-07-my-sublime-env/",
	"title": "My Sublime Environment for Coding",
	"tags": [],
	"description": "",
	"content": " Preliminaries  Download and copy /MinGW/bin path to the Environment Variables. Download Link - www.cb.lk/compile Setup Guide. Link - https://medium.com/@aggarwaldeepak/c-learning-environment-3df85a46784b  Sublime Packages Keyboard Shortcut: Ctrl+Shift+P -\u0026gt; Install Packages -\u0026gt; \u0026ldquo;Package Name\u0026rdquo;\n SublimeAStyleFormatter Terminal Wakatime   More Keyboard Shortcuts  For Building/Compiling: Ctrl+B For Powershell Terminal: Ctrl+Shift+T For Auto-formatting the code: Ctrl+Alt+F For New Tab: Ctrl+N For Closing Current Tab: Ctrl+W For Saving Current: Ctrl+S For Saving As.. Current: Ctrl+Shift+S For Switching Tabs: Ctrl + Tab For Scrolling Up/Down: Ctrl + Up/Down Key For Inserting HTML Tags: write tagname and then press Tab  Snippets in Sublime Tools -\u0026gt; Developer -\u0026gt; New Snippet\u0026hellip;\nLink:: https://www.quora.com/How-can-I-add-my-default-C-C++-code-in-Sublime-Text\n \u0026gt; cpp_default.sublime-snippet  Input from an \u0026ldquo;input.txt\u0026rdquo; file directly in Sublime Tools -\u0026gt; Build System -\u0026gt; New Build System\u0026hellip; Link:: https://www.quora.com/Is-there-a-way-to-compile-and-run-C++-in-Sublime-Text\n\u0026gt; MyC++Build.sublime-bulid  "
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-07-quick-jots/",
	"title": "Quick Jots",
	"tags": [],
	"description": "",
	"content": " The most significant dimension of an array is optional while defining a function with array as an argument.  int example(int arr[][3][3], int n) { } // Function Definition   Short-circuit Evaluation  while(i \u0026lt; len \u0026amp;\u0026amp; arr[i] == 100) // if first condition is false, second is never evaluated while(i \u0026lt; len || arr[i] == 100) // if first condition is true, second is never evaluated  while(i \u0026lt; len \u0026amp;\u0026amp; arr[i] == 100) while(arr[i] == 100 \u0026amp;\u0026amp; i \u0026lt; len) // both these statements are not equivalent as second returns a segmentation fault, because the first is evaluated first  "
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-07-imp/",
	"title": "Important Points",
	"tags": [],
	"description": "",
	"content": "  Arrays are always passed by reference, be it character array(string) in C++.  cin  cin ifnores whitespaces and reads only non-whitespace characters, cin reads from a file known as \u0026lsquo;stdin\u0026rsquo;\u0026ldquo;istream\u0026rdquo; and cin can be invalidated by supplying value of a type that is not expected, cin gets invalidated and never takes any input throughout the rest of the program.  return cin; //will return false if cin has been invalidated before  We can re-validate cin by cin.clear();.\n Enter or \u0026lsquo;\\n\u0026rsquo; is a valid character and is written into and read from the istream file just as other characters, but it is also a delimiter for cin and cin.getline().  cin.get()  it taks only one input at a time and that includes whitespaces.  cin.getline() char str[100]; cin.getline(str,90,'$') //cin.getline(storage_string_name, max_size, 'delimiter_character') [max_size\u0026lt;str_size]   Delimiter is not read by cin.getline(). By default delimiter is \u0026lsquo;\\n\u0026rsquo; aka newline character/Enter.  cin.getline(str,90); // default delimiter`   cin.getline() will not ignore whitespaces and wil go onto read until delimiter, charaters from the file after the delimiter will not be read.  "
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-03-references/",
	"title": "Reference and Array Sorting Algorithms",
	"tags": [],
	"description": "",
	"content": " Pass by Reference void myswap(int \u0026amp;n1, int \u0026amp;n2) //formal parameters /*Called Function Pass by Reference*/ { int temp=n1; n1=n2; n2=temp; } int main() // Calling Function { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; myswap(a,b); //arguments or actual parameters // Function call independent of pass method cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;b; }    Pass by Value - New variables are created\n Pass by Reference - New variables are not created, new names are given to the existing variables.   Algorithms 1. Sorting an Array a. Bubble Sort b. Insertion Sort c. Selection Sort  "
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-07-08-all/",
	"title": "All Notes",
	"tags": [],
	"description": "",
	"content": " Links for all programming notes. [Day-] - Functions and Arrays\n[Day-] - Reference and Array Sorting Algorithms\nPDF Download\n"
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-01-functions-and-arrays/",
	"title": "Functions and Arrays",
	"tags": [],
	"description": "",
	"content": " Precedence of Operators  Division and Multiplication has same priority/precedence - to resolve, we use associativity (Left-to-Right).  Arrays  Arrays are Garbage Declared, Zero Initialized. Bound Checking is not done in C++, no compilation error when ArrayOutOfBound.  Errors  Logical Errors - Difficult to Debug. Semantics Errors - aka Compile Time Errors. Runtime Errors - Pass the Compilation but program fails during Runtime.like dividing by 0.  Undefined Behaviour No behaviour can be defined beforehand even in the same environment.\nImplementation Defined e.g. Data types size difference in different environments, same behaviour in one environment.\nLAW-1 : Whenever accessing any element of an array \u0026ldquo;make sure\u0026rdquo; that the element exists in the array. "
},
{
	"uri": "https://me.abyssaltech.xyz/notes/2018-06-18-strings/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " title: STL - Strings date: 2018-06-18  Strings string is an in-built class in C++.\nstring name; string s(\u0026quot;Abhishek\u0026quot;); string s1 = \u0026quot;Abhishek\u0026quot;; string s3; getline(cin, s3);  For further info, refer here.\n"
},
{
	"uri": "https://me.abyssaltech.xyz/",
	"title": "#Define",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://me.abyssaltech.xyz/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://me.abyssaltech.xyz/notes/",
	"title": "Notes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://me.abyssaltech.xyz/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]