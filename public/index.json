[
{
	"uri": "https://hashdefine.netlify.app/linux-and-tools/terminal/",
	"title": "Terminal",
	"tags": [],
	"description": "",
	"content": "Lorem Ipsum.\n"
},
{
	"uri": "https://hashdefine.netlify.app/regex/resources/",
	"title": "Resources",
	"tags": [],
	"description": "",
	"content": "Web Resources  Regex For Noobs (like me!) - An Illustrated Guide - Janmeppe Regex Course - Launch School Learn Regex The Easy Way - GitHub  Practice  HackerRank - Regex RegexGolf RegexOne Regex101 - Quiz Regex Crossword  Testing and Visualisation  Match Testing  RegexPal Regex101    Visualisation  Regexper Debuggex    Interesting Stuff  TNW - Javascript regular expressions aren\u0026rsquo;t that daunting — here\u0026rsquo;s how to design your own My favorite regex of all time Regex that only matches itself The Many Uses of Regex  Cheat Sheets  Regular Expressions Cheat Sheet Regex Cheat Sheet MIT Cheat Sheet Regular Expressions Cheat Sheet by DaveChild  Resource Lists \u0026amp; References  RexEgg regular-expressions.info Awesome Regex - GitHub  "
},
{
	"uri": "https://hashdefine.netlify.app/rdbms/concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "",
	"content": "Concurrency Control \u0026amp; ACID in Transactions Transactions and their ACID Properties: link\nAtomicity is ensured by: commit and rollback TCL operations of DBMS. We ensure Consistency and Isolation by the following means.\nTransaction States Concurrency and its advantages Concurrency: When two or more transactions are allowed to proceed together. They may be executed out-of-order or in partial order, without affecting the final outcome.\nAdvantages: Less waiting time, less response time, better utilization of resources, increased efficiency.\nSome Problems of Isolation  Dirty Read - reading uncommited values from the buffer, may not always be bad  either read only the commited values from the source or commit as soon as a read-write operation in the destination transaction   Unrepeatable Read - reads same data twice, and get a different value each time. Lost Update (Write-Write Problem)/Blind Write - another transaction commits a different value Phantom Read - reading a deleted item  When we perform a W() (write) operation, we write to a local buffer. It\u0026rsquo;s only at a C (commit) operation that we actually write to our database.\nTypes of Schedules Notes If a schedule has n transactions then total number of serial schedules possible are n!.\nConflict Serializability O(n^2) \u0026amp; Conflict Equivalent Notes\nPrecedence Graph to test Serializability\nView Serializability (NP-Complete) \u0026amp; View Equivalent Superset of Conflict Serializability. Pro Tip: Every View Serailizable schedule has atleast one blind write. If schedule is not CS and has atleast on blind write, then we must prove view equivalence with all n! serial schedules. Notes\nRecoverable Schedule Notes\nDirty read can make a schedule unrecoverable. We must check if dirty read exists and if it does then changes must get commited in the same order/direction in which the dirty read was performed.\n Cascading Rollback - Transactions rollback in the order of dirty read Cascadeless Schedule - Commits as soon as writes, no dirty reads exists Video Strict Schedule - can\u0026rsquo;t read or write before source transaction commits. Need not be serial.  Concurrency Control Techniques References  Knowledge Gate - YouTube GeeksforGeeks - DBMS (see left sidebar on page) Gate Vidyalay - Notes (best short notes)  "
},
{
	"uri": "https://hashdefine.netlify.app/nosql/architecture/",
	"title": "Architecture",
	"tags": [],
	"description": "",
	"content": "RDMS vs NoSQL  NoSQL does not store data in tables/relations and is often distributed/sharded. A NoSQL database has flexible schema. Data is stored in many ways which means it can be document-oriented, column-oriented, graph-based or organized as a KeyValue store. Sometimes called \u0026ldquo;Not only SQL\u0026rdquo; to emphasize the fact that they may support SQL-like query languages. Inherent horizontal scaling, as opposed to inherent vertical scaling in RDBMS. Complex queries like joins are very hard in NoSQL. SQL databases follow ACID properties (Atomicity, Consistency, Isolation and Durability) whereas the NoSQL database follows the Brewer\u0026rsquo;s CAP theorem (Consistency, Availability and Partition tolerance). Normalizations are expensive on RDBMS but not so much in NoSQL. Best suited for scalibility (bcoz of Sharding) and availability (bcoz of Replication of nodes).  Disadvantages  No ACID guarantee Poor update (delete, instert) performance No fixed standard as of now, only community support No robust GUI tools as of now Complex queries like joins are not needed usually but they are very tough to do and costly too Most NoSQL databases offer a concept of eventual consistency in which database changes are propagated to all nodes so queries for data might not return updated data immediately or might result in reading data that is not accurate which is a problem known as stale reads.  Architecture (Cassandra Case Study) Developed by Facebook. It is a column-oriented nosql model.\n Data is sharded in a central Cassandra Cluster, we use hashing to direct queries to particular \u0026ldquo;slice\u0026rdquo;. Load Balancing - To better handle the load, we can create another \u0026ldquo;layer\u0026rdquo; of clusters within a node and apply another hash function for the inner node. Replication gurantees availability - Copy data of the target (of hash) node to the adjacent node. Set replication factor = 1, or any other value between 0 \u0026lt;= RF \u0026lt;= total nodes. Distributed Consensus -\u0026gt; Quorum = 2 i.e. 2 nodes have to agree on a value and send back to query. Can\u0026rsquo;t have RF = Quorum, as incase of a failure of one node, the query will always fail.  References  Gaurav Sen - Introduction to NoSQL databases GfG - Introduction to NoSQL GfG - Difference between SQL and NoSQL Toptal - The Definitive Guide to NoSQL Databases MongoDB - Understanding the Different Types of NoSQL Databases  "
},
{
	"uri": "https://hashdefine.netlify.app/git/notes/",
	"title": "Git",
	"tags": [],
	"description": "",
	"content": "Git SCM notes Basics  Many platforms use Git VCS (version control system), some are GitHub, Bitbucket, etc.. https://www.geeksforgeeks.org/centralized-vs-distributed-version-control-which-one-should-we-choose/  Glossary  Working Tree - home directory structure .git - folder hidden in home directory that contains info for git to work, ex. config, etc\u0026hellip; States in Git - Untracked, Modified, Staged, Commited HEAD - only one head is active at a given time, though we can have mutiple heads.  Git # Setup $ git config --global user.name \u0026#34;Your Name\u0026#34; $ git config --global user.email \u0026#34;your_email@whatever.com\u0026#34; # Setting line preferences (optional ofcourse) $ git config --global core.autocrlf true $ git config --global core.safecrlf true $ git [command] --help $ git init $ git status # Staging $ git add \u0026lt;filename/dirname\u0026gt; # Commiting $ git commit -m \u0026#34;my first commit\u0026#34; # combined (won\u0026#39;t work if any new file was created and is still untracked) $ git commit -am \u0026#34;made changes to existing files only\u0026#34; # Amending Commits $ git commit --amend -m \u0026#34;forgot to add email comment\u0026#34; # the above will delete the previous commit and insert fresh one here # Pushing to remote $ git push # History $ git log # Cutomize it! $ git log --pretty=oneline $ git log --pretty=oneline --max-count=2 $ git log --pretty=oneline --since=\u0026#39;5 minutes ago\u0026#39; $ git log --pretty=oneline --until=\u0026#39;5 minutes ago\u0026#39; $ git log --pretty=oneline --author=\u0026lt;your name\u0026gt; $ git log --pretty=oneline --all # Aliases can be set via terminal or via \u0026#34;.git/config\u0026#34;  [alias] co = checkout ci = commit st = status br = branch hist = log --pretty=format:\u0026#39;%h %ad | %s%d [%an]\u0026#39; --graph --date=short type = cat-file -t dump = cat-file -p # Ignoring files - Any filename added to \u0026#34;.gitignore\u0026#34; will be exempted from vcs $ echo \u0026#34;temp/\u0026#34; \u0026gt;\u0026gt; .gitignore $ echo \u0026#34;private_key\u0026#34; \u0026gt;\u0026gt; .gitignore # Show $ git show \u0026lt;hash\u0026gt; #shows data diff on commit # Go to a previous commit, view hash in log, only a first few chars of the hash will do $ git checkout \u0026lt;hash\u0026gt; # Return to latest commit $ git checkout master # checkout deletes data from uncommited files but not for commited ones, as shown below # Tags - specially named points in Git # View all $ git tag # Set new $ git tag v2-beta # Jump to a previous tag $ git checkout v1 # Remove a tag $ git tag -d v2 # Undoing before staging = checkout file to latest commit $ git checkout \u0026lt;file_to_undo\u0026gt; # Undoing before commiting = reset HEAD to clear any staged changes, and checkout to latest commited version $ git reset HEAD \u0026lt;file_to_undo\u0026gt; $ git checkout \u0026lt;file_to_undo\u0026gt; # Undoing Committed Changes = revert to  $ git revert HEAD # or $ git revert \u0026lt;hash\u0026gt; # Deleting all commits till \u0026lt;hash\u0026gt;, \u0026lt;hash\u0026gt; not included $ git reset --mixed \u0026lt;hash\u0026gt; (commits removed, also unstages files) $ git reset --soft \u0026lt;hash\u0026gt; (not unstaged) $ git reset --hard \u0026lt;hash\u0026gt; (files will be edited accordingly too) # Moving Files = either use terminal command (mv) or git mv $ git mv hello.py lib # same as $ mv hello.py ./lib # Removing files = either use terminal command (rm) or git rm $ git rm path/to/file/hello.py # same as $ rm path/to/file/hello.py # Branching # Create branch $ git branch \u0026lt;branchname\u0026gt; # Checkout to that branch $ git checkout \u0026lt;branchname\u0026gt; # Combined $ git checkout -b \u0026lt;brachname\u0026gt; # Jump across branches $ git checkout new-brach $ git checkout master # View all branches $ git branch # Deleting branches, we can\u0026#39;t delete branch we\u0026#39;re currently on $ git branch -D \u0026lt;branchname\u0026gt; # All commits including branch $ git log --all # ASCII graph $ git log --graph # Merging branches # Fast-Forward Merge (if no commits happen on master after branch) # 3-way Merge (if changes happen to branch as well as master simultaneously after branch, can lead to conflicts) $ git checkout anotherBranch $ git merge master # Merge Conflict - If we make change to both the branch and master, both are different and git can\u0026#39;t choose which one to keep  # Refer: https://stackoverflow.com/questions/24852116/how-does-exactly-a-git-merge-conflict-happen # Resolve conflict manually by editing the files or abort as follows,  $ git merge --abort # Rebase (the junction commit or base commit can be changed using rebase, default is rebasing to last commit on target branch) $ git checkout anotherBranch $ git rebase master # GitHub # Create repo in GitHub in browser # Connect local repo to remote (git remote add \u0026lt;name_of_remote\u0026gt; \u0026lt;url\u0026gt;) $ git remote add origin \u0026lt;https://github.com/user/repository.git\u0026gt; # Pull (git pull \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;) $ git pull origin master # or set upstream to avoid specifying origin master evrytime $ git branch --set-upstream-to=origin/master master # now we can use $ git pull # Push to remote (git push \u0026lt;name_of_remote\u0026gt; \u0026lt;branch name\u0026gt;) $ git push origin master # or $ git push # Collaborating # Clone - Download remote repository to local filesystem. $ git clone \u0026lt;https://github.com/user/repository.git\u0026gt; # Fork - Create a linked remote copy. # PR (Pull Request) - A request to a change that can be either merged or rejected. # We can also add collaborator so that they don\u0026#39;t have to PR everytime # Controlling Collaboration # Protect Branches - Add branch protection rules from browser "
},
{
	"uri": "https://hashdefine.netlify.app/flask/notes/",
	"title": "Flask",
	"tags": [],
	"description": "",
	"content": "Setup  Create a virtual environment  $ python -m venv /path/to/new/virtual/environment #OR $ py -m venv /path/to/new/virtual/environment Activate the virtual environment  $ cd venv_folder/Scripts $ activate.bat Come back to flask app root dir  $ cd .. $ cd .. $ pwd\t#my_flask_app Install Flask  $ pip install flask Flask Basic App Module Structure from flask import Flask app = Flask(__name__) #app routes go here if __name__ == \u0026#39;__main__\u0026#39;: app.run() Two ways to run Flask apps #One $ python app.py #Two - by default, it works only when file is named \u0026#34;app.py\u0026#34; $ flask run #otherwise set env variable, use \u0026#34;set\u0026#34; on Windows instead of \u0026#34;export\u0026#34; $ export FLASK_APP=main.py #we can also enable debug mode like this $ export FLASK_DEBUG=1 main # Syntax: app.run(host, port, debug, options)  app.run(\u0026#39;127.0.0.5\u0026#39;, \u0026#39;4567\u0026#39;, debug=True, options) App Routing @app.route(\u0026#39;path/that/triggers/the/method\u0026#39;) def foobar(): pass #we can have multiple routes for single method @app.route(\u0026#39;/\u0026#39;) @app.route(\u0026#39;home\u0026#39;) def index(): return \u0026#39;Homepage\u0026#39; Point to Note @app.route(\u0026#39;/path/\u0026#39;) #is different from @app.route(\u0026#39;/path\u0026#39;) \u0026#39;\u0026#39;\u0026#39; The former is like a directory path, it will fetch and open path for us in both \u0026#39;/path/\u0026#39; and \u0026#39;/path\u0026#39; scenarios.. while latter is more like a file path, if we go to \u0026#39;localhost:5000/path/\u0026#39;, it will fail to find the correct one and give 404 error \u0026#39;\u0026#39;\u0026#39; Dynamic Parameters in URL #we can also have dynamic parameters in url @app.route(\u0026#39;/\u0026lt;name\u0026gt;\u0026#39;) def index(name): return \u0026#39;Welcome, \u0026#39; + name\t#we can enforce strict typing too, \u0026#39;str\u0026#39; works with all types but \u0026#39;int\u0026#39; won\u0026#39;t take in strings, as expected @app.route(\u0026#39;/\u0026lt;int:age\u0026gt;\u0026#39;) def index(age): return f\u0026#39;You are {age}\u0026#39; \u0026#39;\u0026#39;\u0026#39; string: default int: used to convert the string to the integer float: used to convert the string to the float. path: It can accept the slashes given in the URL. \u0026#39;\u0026#39;\u0026#39; #we can create url rule/route/trigger for an existing method using \u0026#34;add_url_rule()\u0026#34; # Syntax: add_url_rule(\u0026lt;url rule\u0026gt;, \u0026lt;endpoint\u0026gt;, \u0026lt;view function\u0026gt;) add_url_rule(\u0026#39;/new_home\u0026#39;, \u0026#39;home2\u0026#39;, index) Redirection #vars are optional redirect(url_for(\u0026#39;another_method_name\u0026#39;, var=1, ...)) HTTP Methods # Default method is GET # Specifying expected methods in approute @app.route(\u0026#39;/path\u0026#39;, methods=[\u0026#39;GET\u0026#39;,\u0026#39;POST\u0026#39;]) # Check method with which function was called if request.method == \u0026#39;POST\u0026#39;: pass # Data retrieval with POST var = request.form[\u0026#39;data\u0026#39;] # Data retrieval with GET var = request.args.get(\u0026#39;data\u0026#39;) Configuration (config) #config is an in-built dictionary in Flask, we set values in it app.config[\u0026#39;DEBUG\u0026#39;] = True Sessions # Keeps data persistent throughout webpages # Implemented in Flask using just a simple dictionary from flask import session # Set secret_key app.secret_key = \u0026#39;anything\u0026#39; # alternate way --\u0026gt; app.config[\u0026#39;SECRET_KEY\u0026#39;] = \u0026#39;anything\u0026#39; # Add value session[\u0026#39;name\u0026#39;] = \u0026#39;Abhishek\u0026#39; # Check if the value is in session if \u0026#39;name\u0026#39; in session: pass # Close session session.pop(\u0026#39;name\u0026#39;, None) Cookies # We always set them on the response objects and send them to store on client side in a txt form, # contrary to session which is sever side storage # Make response object resObj = make_response(\u0026lt;h1\u0026gt; Cookie is set in browser! \u0026lt;/h1\u0026gt;) # Set cookies on it resObj.set_cookie(\u0026#39;name\u0026#39;, \u0026#39;Abhishek\u0026#39;) # Access cookies wherever needed request.cookies.get(\u0026#39;name\u0026#39;) Jinja Templating  Templates goes into app-folder/templates/ Static files like CSS and JS files go into app-folder/static/  render_template(\u0026#39;login.html\u0026#39;, user=user) #vars are optional \u0026lt;h3\u0026gt; Username is: {{user}} \u0026lt;/h3\u0026gt; {{ }} for variables \u0026amp; expressions {% %} for blocks, if-else, loops {% end--- %} Static Files \u0026lt;img src=\u0026#34;{{ url_for(\u0026#39;static\u0026#39;, filename=\u0026#39;images/mylogo.png\u0026#39;) }}\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;spreadsheet\u0026#34; src=\u0026#34;{{ url_for(\u0026#39;static\u0026#39;, filename=\u0026#39;css/main.css\u0026#39;) }}\u0026#34;\u0026gt; Template Inheritence \u0026lt;!-- base.html --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;{% block title %}{% endblock %}\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {% block title %}{% endblock %}\t\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; {% block title %} {% endblock %} acts as a placeholder\n{% extends \u0026#39;base.html\u0026#39; %} {% block title %} Homepage {% endblock %}\t{% block title %} \u0026lt;h2\u0026gt; This is page body. \u0026lt;/h2\u0026gt; {% endblock %}\tBy default, if we have anything in base.html\u0026rsquo;s body block, it will be overwritten completely. To retain it, use super() in child\u0026rsquo;s block.\n{% block title %} {% super() %} \u0026lt;h2\u0026gt; This is page body. \u0026lt;/h2\u0026gt; {% endblock %}\tIncluding content from another webpage {% include \u0026#39;another.html\u0026#39; %}  This is two way though, we can now access variables available on our page on another.html too.\n Flask Bootstrap Official Guide\n$ pip install flask-bootstrap from flask import Flask from flask_bootstrap import Bootstrap app = Flask(__name__) Bootstrap(app) # further code... Database sqlite setup \u0026gt;\u0026gt;\u0026gt; sqlite3 data.db \u0026gt;\u0026gt;\u0026gt; create table users(id integer primary key autoincrement, name text, location text); \u0026gt;\u0026gt;\u0026gt; .tables users #insert into ... Shortcut:\n\u0026gt;\u0026gt;\u0026gt; sqlite3 \u0026lt; schema\t#schema is a simple text file containing our create table command(s) Or use a python script\nimport sqlite3 con = sqlite3.connect(\u0026#34;employee.db\u0026#34;) #print(\u0026#34;Database opened successfully\u0026#34;)  con.execute(\u0026#34;create table Employees (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, email TEXT UNIQUE NOT NULL, address TEXT NOT NULL)\u0026#34;) #print(\u0026#34;Table created successfully\u0026#34;)  con.close() # Standard Helper Procedures from flask import g import sqlite3 def connect_db(): sql = sqlite3.connect(\u0026#39;/path/to/data.db\u0026#39;) sql.row_factory = sqlite3.Row return sql def get_db(): if not hasattr(g, \u0026#39;sqlite_db\u0026#39;): g.sqlite_db = connect_db() return g.sqlite_db # Below goes in the manifest file @app.teardown_appcontext def close_db(error): if hasattr(g, \u0026#39;sqlite_db\u0026#39;): g.sqlite_db.close() # Querying and commiting db = get_db() result = db.execute(\u0026#39;SELECT ? FROM Employee\u0026#39;, (name,))\t#second argument is either a tuple or a list  db.commit() full_output = result.fetchall() #single_row = result.fetchone() #db.rollback() Best security practices # Use turly random string as secret key for sessions import os app.config[\u0026#39;SECRET_KEY\u0026#39;] = os.urandom(24)\t#generates random string # Always hash passwords before storing them in the database from werkzeug.security import generate_password_hash, check_password_hash # generate_password_hash(request.form[\u0026#39;password\u0026#39;], method=\u0026#39;sha256\u0026#39;) # check_password_hash(request.form[\u0026#39;password\u0026#39;], query_result[\u0026#39;password\u0026#39;])  "
},
{
	"uri": "https://hashdefine.netlify.app/python/notes/",
	"title": "Notes",
	"tags": [],
	"description": "",
	"content": "# Single line comments start with a number symbol. \u0026#34;\u0026#34;\u0026#34; Multiline strings can be written using three \u0026#34;s or \u0026#39;s, and are often used as documentation. \u0026#34;\u0026#34;\u0026#34; #################################################### ## 1. Primitive Datatypes and Operators #################################################### # Numbers are objects #Integer Literals a = 0b1010 #Binary Literals (0b / 0B) b = 100 #Decimal Literal c = 0o310 #Octal Literal (0c / 0C) d = 0x12c #Hexadecimal Literal (0x / 0X) #Float Literal float_1 = 10.5 float_2 = 1.5e2 #Complex Literal  x = 3.14j y = 3+6j print(x, x.imag, x.real)\t#3.14j 3.14 0.0 print(y, y.imag, y.real)\t#(3+6j) 6.0 3.0 # Math is what you would expect 1 + 1 # =\u0026gt; 2 8 - 1 # =\u0026gt; 7 10 * 2 # =\u0026gt; 20 35 / 5 # =\u0026gt; 7.0 # Integer division rounds down (floor) for both positive and negative numbers, unlike truncate C/C++ 5 // 3 # =\u0026gt; 1 -5 // 3 # =\u0026gt; -2 5.0 // 3.0 # =\u0026gt; 1.0 # works on floats too -5.0 // 3.0 # =\u0026gt; -2.0 # The result of division is always a float 10.0 / 3 # =\u0026gt; 3.3333333333333335 # Modulo operation 7 % 3 # =\u0026gt; 1 # i % j have the same sign as j, unlike C -7 % 3 # =\u0026gt; 2 # Exponentiation (x**y, x to the yth power) 2**3 # =\u0026gt; 8 # Enforce precedence with parentheses 1 + 3 * 2 # =\u0026gt; 7 (1 + 3) * 2 # =\u0026gt; 8 # Boolean values are primitives (Note: the capitalization) True # =\u0026gt; True False # =\u0026gt; False # Boolean Operators # Note \u0026#34;and\u0026#34; and \u0026#34;or\u0026#34; are case-sensitive True and False # =\u0026gt; False False or True # =\u0026gt; True not True # =\u0026gt; False not False # =\u0026gt; True # True and False are actually 1 and 0 but with different keywords True + True # =\u0026gt; 2 True * 8 # =\u0026gt; 8 False - 5 # =\u0026gt; -5 # Comparison operators look at the numerical value of True and False 0 == False # =\u0026gt; True 1 == True # =\u0026gt; True 2 == True # =\u0026gt; False -5 != False # =\u0026gt; True # Using boolean logical operators on ints casts them to booleans for evaluation, but their non-cast value is returned # Don\u0026#39;t mix up with bool(ints) and bitwise and/or (\u0026amp;,|) bool(0) # =\u0026gt; False bool(4) # =\u0026gt; True bool(-6) # =\u0026gt; True 0 and 2 # =\u0026gt; 0 -5 or 0 # =\u0026gt; -5 #Comparisons \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= == != # Seeing whether a value is in a range 1 \u0026lt; 2 and 2 \u0026lt; 3 # =\u0026gt; True 2 \u0026lt; 3 and 3 \u0026lt; 2 # =\u0026gt; False # Chaining makes this look nicer 1 \u0026lt; 2 \u0026lt; 3 # =\u0026gt; True 2 \u0026lt; 3 \u0026lt; 2 # =\u0026gt; False #Assignments can also be chained a = b = c = 5 a, b, c = 3, 4, 5 #Tuple Unpacking #Identity operators (is/ is not) compares by object id()  # (is vs. ==) is checks if two variables refer to the same object, but == checks # if the objects pointed to have the same values. a = [1, 2, 3, 4] # Point a at a new list, [1, 2, 3, 4] b = a # Point b at what a is pointing to b is a # =\u0026gt; True, a and b refer to the same object b == a # =\u0026gt; True, a\u0026#39;s and b\u0026#39;s objects are equal b = [1, 2, 3, 4] # Point b at a new list, [1, 2, 3, 4] b is a # =\u0026gt; False, a and b do not refer to the same object b == a # =\u0026gt; True, a\u0026#39;s and b\u0026#39;s objects are equal #Mutable objects such as Dict, List, Sets will have id() that is different even if they have same data inside #Immutable objects such as Numbers, strings, tuples, etc... have same id() for objects that have same data. Ex - 3, (1,2), \u0026#39;Abhi\u0026#39;  #Membership Operator (auto-loops over collections) in not in #Bitwise Operators \u0026amp; | ~ ^ \u0026lt;\u0026lt; \u0026gt;\u0026gt; # Strings are created with \u0026#34; or \u0026#39; \u0026#34;This is a string.\u0026#34; \u0026#39;This is also a string.\u0026#39; #String literals unicode = u\u0026#34;\\u00dcnic\\u00f6de\u0026#34;\t# =\u0026gt; Ünicöde raw_str = r\u0026#34;raw \\n string\u0026#34;\t# =\u0026gt; raw \\n string # Strings can be added too \u0026#34;Hello \u0026#34; + \u0026#34;world!\u0026#34; # =\u0026gt; \u0026#34;Hello world!\u0026#34; # String literals (but not variables) can be concatenated without using \u0026#39;+\u0026#39; \u0026#34;Hello \u0026#34; \u0026#34;world!\u0026#34; # =\u0026gt; \u0026#34;Hello world!\u0026#34; #Multiplication on strings print(\u0026#39;hey\u0026#39; * 2)\t# =\u0026gt; heyhey # A string can be treated like a list of characters \u0026#34;Hello world!\u0026#34;[0] # =\u0026gt; \u0026#39;H\u0026#39; #But they are an immutable collection \u0026#34;Hello\u0026#34;[1] = \u0026#34;u\u0026#34;\t#TypeError: assigment not supported # You can find the length of a string len(\u0026#34;This is a string\u0026#34;) # =\u0026gt; 16 #Formatting #C-like name = \u0026#39;Abhi\u0026#39; print(\u0026#39;My name is: %s\u0026#39; %name) # =\u0026gt; My name is: Abhi (notice no comma) #format() function of String object name = \u0026#39;Abhishek\u0026#39; title = \u0026#39;Arya\u0026#39; print(\u0026#39;My name is: {} {}\u0026#39;.format(name, title)) # =\u0026gt; My name is: Abhishek Arya #Keyword arguments are allowed just like any other function print(\u0026#39;My name is: {} {}\u0026#39;.format(title = \u0026#39;Arya\u0026#39;, name=\u0026#39;Abhishek\u0026#39;)) # =\u0026gt; My name is: Abhishek Arya # f-strings (in Python 3.6+) name = \u0026#34;Arya\u0026#34; f\u0026#34;He said his name is {name}.\u0026#34; # =\u0026gt; \u0026#34;He said his name is Arya.\u0026#34; # You can basically put any Python expression inside the braces and it will be output in the string. f\u0026#34;{name} is {len(name)} characters long.\u0026#34; # =\u0026gt; \u0026#34;Arya is 4 characters long.\u0026#34; # None is an object None # =\u0026gt; None # Don\u0026#39;t use the equality \u0026#34;==\u0026#34; symbol to compare objects to None # Use \u0026#34;is\u0026#34; instead. This checks for equality of object identity. \u0026#34;etc\u0026#34; is None # =\u0026gt; False None is None # =\u0026gt; True # None, 0, and empty strings/lists/dicts/tuples all evaluate to False. # All other values are True bool(0) # =\u0026gt; False bool(\u0026#34;\u0026#34;) # =\u0026gt; False bool([]) # =\u0026gt; False bool({}) # =\u0026gt; False bool(()) # =\u0026gt; False #################################################### ## 2. Variables and Collections #################################################### # Python has a print function print(\u0026#34;I\u0026#39;m Python. Nice to meet you!\u0026#34;) # =\u0026gt; I\u0026#39;m Python. Nice to meet you! # By default the print function also prints out a newline (\\n) character at the end. # Use the optional argument end to change the end string. print(\u0026#34;Hello, World\u0026#34;, end=\u0026#34;!\u0026#34;) # =\u0026gt; Hello, World! # sep for custom separator delimiters print(\u0026#34;Hello\u0026#34;, \u0026#34;Bye\u0026#34;, sep=\u0026#34;\u0026amp;\u0026#34;) # =\u0026gt; Hello\u0026amp;Bye (only works if there\u0026#39;s a comma in between strings) # Simple way to get input data from console input_string_var = input(\u0026#34;Enter some data: \u0026#34;) # Returns the data as a string by default input_int_var = int(input(\u0026#34;Enter a number: \u0026#34;)) # Returns the data as an integer # There are no declarations, only assignments. # Convention is to use lower_case_with_underscores some_var = 5 print(some_var) # =\u0026gt; 5 # Accessing a previously unassigned variable is an exception. # See Control Flow to learn more about exception handling. some_unknown_var # Raises a NameError # if can be used as an expression # Equivalent of C\u0026#39;s \u0026#39;?:\u0026#39; ternary operator \u0026#34;yay!\u0026#34; if 0 \u0026gt; 1 else \u0026#34;nay!\u0026#34; # =\u0026gt; \u0026#34;nay!\u0026#34; # Lists store sequences li = [] # You can start with a prefilled list other_li = [4, 5, 6] # Add stuff to the end of a list with append li.append(1) # li is now [1] li.append(2) # li is now [1, 2] li.append(4) # li is now [1, 2, 4] li.append(3) # li is now [1, 2, 4, 3] # Remove from a given index with pop, returns popped element popped_element = li.pop() # =\u0026gt; 3 and li is now [1, 2, 4] popped_element = li.pop(1) # =\u0026gt; 2 and li is now [1, 4] # Access a list like you would any array li[0] # =\u0026gt; 1 # Negative indices start from -1, to look at the last element li[-1] # =\u0026gt; 3 # Looking out of bounds is an IndexError li[4] # Raises an IndexError # You can look at ranges with slice syntax. # The start index is included, the end index is not # (It\u0026#39;s a closed/open range for you mathy types.) li[1:3] # Return list from index 1 to 3 =\u0026gt; [2, 4] li[2:] # Return list starting from index 2 =\u0026gt; [4, 3] li[:3] # Return list from beginning until index 3 =\u0026gt; [1, 2, 4] li[::2] # Return list selecting every second entry =\u0026gt; [1, 4] li[::-1] # Return list in reverse order =\u0026gt; [3, 4, 2, 1] # Use any combination of these to make advanced slices # li[start:end:step] # Make a one layer deep copy using slices li2 = li[:] # =\u0026gt; li2 = [1, 2, 4, 3] but (li2 is li) will result in false. # Remove arbitrary elements from a list with \u0026#34;del\u0026#34; del li[2] # li is now [1, 2, 3] # Remove first occurrence of a value li.remove(2) # li is now [1, 3] li.remove(2) # Raises a ValueError as 2 is not in the list # Insert an element at a specific index li.insert(1, 2) # li is now [1, 2, 3] again # Get the index of the first item found matching the argument li.index(2) # =\u0026gt; 1 li.index(4) # Raises a ValueError as 4 is not in the list # You can add lists # Note: values for li and for other_li are not modified. li + other_li # =\u0026gt; [1, 2, 3, 4, 5, 6] # Concatenate lists with \u0026#34;extend()\u0026#34; li.extend(other_li) # Now li is [1, 2, 3, 4, 5, 6] li.extend([7, 8, 9]) # Now li is [1, 2, 3, 4, 5, 6, 7, 8, 9] # Check for existence in a list with \u0026#34;in\u0026#34;, it performs search on entire collection 1 in li # =\u0026gt; True # Examine the length with \u0026#34;len()\u0026#34; len(li) # =\u0026gt; 6 # Tuples are like lists but are immutable. tup = (1, 2, 3) tup[0] # =\u0026gt; 1 tup[0] = 3 # Raises a TypeError # We can change mutable elements of an immutable collection n_tuple = (\u0026#34;mouse\u0026#34;, [8, 4, 5], (1, 2, 3)) n_tuple[1][0] = 3 print(n_tuple)\t# =\u0026gt; (\u0026#39;mouse\u0026#39;, [3, 4, 5], (1, 2, 3)) # Note that a tuple of length one has to have a comma after the last element but # tuples of other lengths, even zero, do not. type((1)) # =\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; type((1,)) # =\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; type(()) # =\u0026gt; \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; # You can do most of the list operations on tuples too len(tup) # =\u0026gt; 3 tup + (4, 5, 6) # =\u0026gt; (1, 2, 3, 4, 5, 6) tup[:2] # =\u0026gt; (1, 2) 2 in tup # =\u0026gt; True # You can unpack tuples (or lists) into variables a, b, c = (1, 2, 3) # a is now 1, b is now 2 and c is now 3 # You can also do extended unpacking a, *b, c = (1, 2, 3, 4) # a is now 1, b is now [2, 3] and c is now 4 # Tuples are created by default if you leave out the parentheses d, e, f = 4, 5, 6 # tuple 4, 5, 6 is unpacked into variables d, e and f # respectively such that d = 4, e = 5 and f = 6 # Now look how easy it is to swap two values e, d = d, e # d is now 5 and e is now 4 # Dictionaries store mappings from keys to values empty_dict = {} # Here is a prefilled dictionary filled_dict = {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} # Note keys for dictionaries have to be immutable types. This is to ensure that # the key can be converted to a constant hash value for quick look-ups. # Immutable types include ints, floats, strings, tuples. invalid_dict = {[1,2,3]: \u0026#34;123\u0026#34;} # =\u0026gt; Raises a TypeError: unhashable type: \u0026#39;list\u0026#39; valid_dict = {(1,2,3):[1,2,3]} # Values can be of any type, however. # Look up values with [] filled_dict[\u0026#34;one\u0026#34;] # =\u0026gt; 1 # Get all keys as an iterable with \u0026#34;keys()\u0026#34;. We need to wrap the call in list() # to turn it into a list. We\u0026#39;ll talk about those later. Note - for Python # versions \u0026lt;3.7, dictionary key ordering is not guaranteed. Your results might # not match the example below exactly. However, as of Python 3.7, dictionary # items maintain the order at which they are inserted into the dictionary. list(filled_dict.keys()) # =\u0026gt; [\u0026#34;three\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;one\u0026#34;] in Python \u0026lt;3.7 list(filled_dict.keys()) # =\u0026gt; [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;] in Python 3.7+ # Get all values as an iterable with \u0026#34;values()\u0026#34;. Once again we need to wrap it # in list() to get it out of the iterable. Note - Same as above regarding key # ordering. list(filled_dict.values()) # =\u0026gt; [3, 2, 1] in Python \u0026lt;3.7 list(filled_dict.values()) # =\u0026gt; [1, 2, 3] in Python 3.7+ print(list(filled_dict.items())\t# =\u0026gt; [(\u0026#39;one\u0026#39;, 1), (\u0026#39;two\u0026#39;, 2), (\u0026#39;three\u0026#39;, 3)] # Check for existence of keys only in a dictionary with \u0026#34;in\u0026#34; \u0026#34;one\u0026#34; in filled_dict # =\u0026gt; True 1 in filled_dict # =\u0026gt; False # Looking up a non-existing key is a KeyError filled_dict[\u0026#34;four\u0026#34;] # KeyError # Use \u0026#34;get()\u0026#34; method to avoid the KeyError filled_dict.get(\u0026#34;one\u0026#34;) # =\u0026gt; 1 filled_dict.get(\u0026#34;four\u0026#34;) # =\u0026gt; None # The get method supports a default argument when the value is missing filled_dict.get(\u0026#34;one\u0026#34;, 4) # =\u0026gt; 1 filled_dict.get(\u0026#34;four\u0026#34;, 4) # =\u0026gt; 4 # \u0026#34;setdefault()\u0026#34; inserts into a dictionary only if the given key isn\u0026#39;t present filled_dict.setdefault(\u0026#34;five\u0026#34;, 5) # filled_dict[\u0026#34;five\u0026#34;] is set to 5 filled_dict.setdefault(\u0026#34;five\u0026#34;, 6) # filled_dict[\u0026#34;five\u0026#34;] is still 5 # Adding to a dictionary filled_dict.update({\u0026#34;four\u0026#34;:4}) # =\u0026gt; {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3, \u0026#34;four\u0026#34;: 4} filled_dict[\u0026#34;four\u0026#34;] = 4 # another way to add to dict # Remove keys from a dictionary with del del filled_dict[\u0026#34;one\u0026#34;] # Removes the key \u0026#34;one\u0026#34; from filled dict # From Python 3.5 you can also use the additional unpacking options {\u0026#39;a\u0026#39;: 1, **{\u0026#39;b\u0026#39;: 2}} # =\u0026gt; {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} {\u0026#39;a\u0026#39;: 1, **{\u0026#39;a\u0026#39;: 2}} # =\u0026gt; {\u0026#39;a\u0026#39;: 2} # Sets store ... well sets (unordered and unique items) empty_set = set() # Initialize a set with a bunch of values. Yeah, it looks a bit like a dict. Sorry. some_set = {1, 1, 2, 2, 3, 4} # some_set is now {1, 2, 3, 4} # Similar to keys of a dictionary, elements of a set have to be immutable. invalid_set = {[1], 1} # =\u0026gt; Raises a TypeError: unhashable type: \u0026#39;list\u0026#39; valid_set = {(1,), 1} # Add one more item to the set filled_set = some_set filled_set.add(5) # filled_set is now {1, 2, 3, 4, 5} # Sets do not have duplicate elements filled_set.add(5) # it remains as before {1, 2, 3, 4, 5} # Do set intersection with \u0026amp; other_set = {3, 4, 5, 6} filled_set \u0026amp; other_set # =\u0026gt; {3, 4, 5} # Do set union with | filled_set | other_set # =\u0026gt; {1, 2, 3, 4, 5, 6} # Do set difference with - {1, 2, 3, 4} - {2, 3, 5} # =\u0026gt; {1, 4} # Do set symmetric difference with ^ {1, 2, 3, 4} ^ {2, 3, 5} # =\u0026gt; {1, 4, 5} # Check if set on the left is a superset of set on the right {1, 2} \u0026gt;= {1, 2, 3} # =\u0026gt; False # Check if set on the left is a subset of set on the right {1, 2} \u0026lt;= {1, 2, 3} # =\u0026gt; True # Check for existence in a set with in 2 in filled_set # =\u0026gt; True 10 in filled_set # =\u0026gt; False # Make a one layer deep copy filled_set = some_set.copy() # filled_set is {1, 2, 3, 4, 5} filled_set is some_set # =\u0026gt; False # Frozensets also exist which are just immutable sets A = frozenset([1, 2, 3, 4]) B = frozenset([3, 4, 5, 6]) A.isdisjoint(B) # =\u0026gt; False A.difference(B) # =\u0026gt; frozenset({1, 2}) A | B # =\u0026gt; frozenset({1, 2, 3, 4, 5, 6}) A.add(3) # =\u0026gt; AttributeError: \u0026#39;frozenset\u0026#39; object has no attribute \u0026#39;add\u0026#39; #################################################### ## 3. Control Flow #################################################### # Let\u0026#39;s just make a variable some_var = 5 # Here is an if statement. Indentation is significant in Python! # Convention is to use four spaces, not tabs. # This prints \u0026#34;some_var is smaller than 10\u0026#34; if some_var \u0026gt; 10: print(\u0026#34;some_var is totally bigger than 10.\u0026#34;) elif some_var \u0026lt; 10: # This elif clause is optional. print(\u0026#34;some_var is smaller than 10.\u0026#34;) else: # This is optional too. print(\u0026#34;some_var is indeed 10.\u0026#34;) \u0026#34;\u0026#34;\u0026#34; For loops iterate over lists prints: dog is a mammal cat is a mammal mouse is a mammal \u0026#34;\u0026#34;\u0026#34; for animal in [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;mouse\u0026#34;]: # You can use format() to interpolate formatted strings print(\u0026#34;{} is a mammal\u0026#34;.format(animal)) \u0026#34;\u0026#34;\u0026#34; \u0026#34;range(number)\u0026#34; returns an iterable of numbers from zero to the given number prints: 0 1 2 3 \u0026#34;\u0026#34;\u0026#34; for i in range(4): print(i) \u0026#34;\u0026#34;\u0026#34; \u0026#34;range(lower, upper)\u0026#34; returns an iterable of numbers from the lower number to the upper number prints: 4 5 6 7 \u0026#34;\u0026#34;\u0026#34; for i in range(4, 8): print(i) \u0026#34;\u0026#34;\u0026#34; \u0026#34;range(lower, upper, step)\u0026#34; returns an iterable of numbers from the lower number to the upper number, while incrementing by step. If step is not indicated, the default value is 1. prints: 4 6 \u0026#34;\u0026#34;\u0026#34; for i in range(4, 8, 2): print(i) \u0026#34;\u0026#34;\u0026#34; To loop over a list, and retrieve both the index and the value of each item in the list prints: 0 dog 1 cat 2 mouse \u0026#34;\u0026#34;\u0026#34; animals = [\u0026#34;dog\u0026#34;, \u0026#34;cat\u0026#34;, \u0026#34;mouse\u0026#34;] for i, value in enumerate(animals): print(i, value) else: pass \u0026#34;\u0026#34;\u0026#34; While loops go until a condition is no longer met. prints: 0 1 2 3 \u0026#34;\u0026#34;\u0026#34; x = 0 while x \u0026lt; 4: print(x) x += 1 # Shorthand for x = x + 1 break continue #works the same # Both \u0026#34;for\u0026#34; and \u0026#34;while\u0026#34; loops have an optional \u0026#34;else:\u0026#34;\u0026#34; part which executes only when the loop condition becomes \u0026#34;False\u0026#34;  #(by default always at the end of the loop), but we can skip the \u0026#34;else\u0026#34; part by using \u0026#34;break\u0026#34; inside the loop # Handle exceptions with a try/except block try: # Use \u0026#34;raise\u0026#34; to raise an error raise IndexError(\u0026#34;This is an index error\u0026#34;) except IndexError as e: pass # Pass is just a no-op. Usually you would do recovery here. except (TypeError, NameError): pass # Multiple exceptions can be handled together, if required. else: # Optional clause to the try/except block. Must follow all except blocks print(\u0026#34;All good!\u0026#34;) # Runs only if the code in try raises no exceptions finally: # Execute under all circumstances print(\u0026#34;We can clean up resources here\u0026#34;) # Instead of try/finally to cleanup resources you can use a with statement with open(\u0026#34;myfile.txt\u0026#34;) as f: for line in f: print(line) # Writing to a file contents = {\u0026#34;aa\u0026#34;: 12, \u0026#34;bb\u0026#34;: 21} with open(\u0026#34;myfile1.txt\u0026#34;, \u0026#34;w+\u0026#34;) as file: file.write(str(contents)) # writes a string to a file with open(\u0026#34;myfile2.txt\u0026#34;, \u0026#34;w+\u0026#34;) as file: file.write(json.dumps(contents)) # writes an object to a file # Reading from a file with open(\u0026#39;myfile1.txt\u0026#39;, \u0026#34;r+\u0026#34;) as file: contents = file.read() # reads a string from a file print(contents) # print: {\u0026#34;aa\u0026#34;: 12, \u0026#34;bb\u0026#34;: 21} with open(\u0026#39;myfile2.txt\u0026#39;, \u0026#34;r+\u0026#34;) as file: contents = json.load(file) # reads a json object from a file print(contents) # print: {\u0026#34;aa\u0026#34;: 12, \u0026#34;bb\u0026#34;: 21} # Don\u0026#39;t forget to close files file.close() #################################################### ## 4. Functions #################################################### # Use \u0026#34;def\u0026#34; to create new functions def add(x, y): \u0026#34;\u0026#34;\u0026#34;optional docstring that can be referenced by func_name.__doc__\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;x is {} and y is {}\u0026#34;.format(x, y)) return x + y # Return values with a return statement return #returns None # Define functions with optional default arguments def foo(x, y=\u0026#39;Welcome\u0026#39;)\t# Default argument y return x + \u0026#39; \u0026#39; + y foo(\u0026#39;Hi\u0026#39;)\t# =\u0026gt; Hi Welcome foo(\u0026#39;Hello\u0026#39;, \u0026#39;Bonjour\u0026#39;)\t# =\u0026gt; Hello Bonjour # Calling functions with parameters add(5, 6) # =\u0026gt; prints out \u0026#34;x is 5 and y is 6\u0026#34; and returns 11 # Another way to call functions is with keyword arguments add(y=6, x=5) # Keyword arguments can arrive in any order. # You can define functions that take a variable number of # positional arguments, stores all arguments in a tuple as in \u0026#34;args\u0026#34; below def varargs(*args): return args varargs(1, 2, 3) # =\u0026gt; (1, 2, 3) # You can define functions that take a variable number of # keyword arguments, as well def keyword_args(**kwargs): return kwargs # Let\u0026#39;s call it to see what happens, kwargs is a dictionary here keyword_args(big=\u0026#34;foot\u0026#34;, loch=\u0026#34;ness\u0026#34;) # =\u0026gt; {\u0026#34;big\u0026#34;: \u0026#34;foot\u0026#34;, \u0026#34;loch\u0026#34;: \u0026#34;ness\u0026#34;} # You can do both at once, if you like def all_the_args(*args, **kwargs): print(args) print(kwargs) \u0026#34;\u0026#34;\u0026#34; all_the_args(1, 2, a=3, b=4) prints: (1, 2) {\u0026#34;a\u0026#34;: 3, \u0026#34;b\u0026#34;: 4} \u0026#34;\u0026#34;\u0026#34; # When calling functions, you can do the opposite of args/kwargs! # Use * to expand tuples and use ** to expand kwargs. args = (1, 2, 3, 4) kwargs = {\u0026#34;a\u0026#34;: 3, \u0026#34;b\u0026#34;: 4} all_the_args(*args) # equivalent to all_the_args(1, 2, 3, 4) all_the_args(**kwargs) # equivalent to all_the_args(a=3, b=4) all_the_args(*args, **kwargs) # equivalent to all_the_args(1, 2, 3, 4, a=3, b=4) # Returning multiple values (with tuple assignments, basically a tuple is returned from swap() which is unpacked into x, y) def swap(x, y): return y, x # Return multiple values as a tuple without the parenthesis. # (Note: parenthesis have been excluded but can be included) x = 1 y = 2 x, y = swap(x, y) # =\u0026gt; x = 2, y = 1 # (x, y) = swap(x,y) # Again parenthesis have been excluded but can be included. # Function Scope ---\u0026gt; LEGB (Local, Enclosing, Global, Built-in) x = 5 def set_x(num): # Local var x not the same as global variable x x = num # =\u0026gt; new local var created with value = 43 print(x) # =\u0026gt; 43 def set_global_x(num): global x # =\u0026gt; declaring global var x in local scope print(x) # =\u0026gt; 5 x = num # global var x is now set to 66 print(x) # =\u0026gt; 66 set_x(43) set_global_x(66) #nonlocal (Enclosing Scope) (changes the enclosing scope vars) def outer(): x = \u0026#34;local\u0026#34; def inner(): nonlocal x x = \u0026#34;nonlocal\u0026#34; print(\u0026#34;inner:\u0026#34;, x) inner() print(\u0026#34;outer:\u0026#34;, x) outer() \u0026#39;\u0026#39;\u0026#39; #inner: nonlocal #outer: nonlocal \u0026#39;\u0026#39;\u0026#39; #global inside inner function (creates and sets a new global var) def foo(): x = 20 def bar(): global x x = 25 print(\u0026#34;Before calling bar: \u0026#34;, x) print(\u0026#34;Calling bar now\u0026#34;) bar() print(\u0026#34;After calling bar: \u0026#34;, x) foo() print(\u0026#34;x in main: \u0026#34;, x) \u0026#39;\u0026#39;\u0026#39; Before calling bar: 20 Calling bar now After calling bar: 20 x in main: 25 \u0026#39;\u0026#39;\u0026#39; # Python has first class functions (functions defined inside other functions) def create_adder(x): def adder(y): return x + y return adder add_10 = create_adder(10) add_10(3) # =\u0026gt; 13 # There are also anonymous functions (lambda args: body), notice there is no return (lambda x: x \u0026gt; 2)(3) # =\u0026gt; True (lambda x, y: x ** 2 + y ** 2)(2, 1) # =\u0026gt; 5 # There are built-in higher order functions list(map(add_10, [1, 2, 3])) # =\u0026gt; [11, 12, 13] list(map(max, [1, 2, 3], [4, 2, 1])) # =\u0026gt; [4, 2, 3] list(filter(lambda x: x \u0026gt; 5, [3, 4, 5, 6, 7])) # =\u0026gt; [6, 7] # We can use list comprehensions for nice maps and filters # List comprehension stores the output as a list which can itself be a nested list [add_10(i) for i in [1, 2, 3]] # =\u0026gt; [11, 12, 13] [x for x in [3, 4, 5, 6, 7] if x \u0026gt; 5] # =\u0026gt; [6, 7] # You can construct set and dict comprehensions as well. {x for x in \u0026#39;abcddeef\u0026#39; if x not in \u0026#39;abc\u0026#39;} # =\u0026gt; {\u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;} {x: x**2 for x in range(5)} # =\u0026gt; {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} #################################################### ## 5. Modules and Packages #################################################### \u0026#39;\u0026#39;\u0026#39; Functions. Modules -\u0026gt; .py file containing statements and functions Packages -\u0026gt; folder having a module named __init__.py inside of it \u0026#39;\u0026#39;\u0026#39; # You can import modules import math print(math.sqrt(16)) # =\u0026gt; 4.0 # You can get specific functions from a module from math import ceil, floor print(ceil(3.7)) # =\u0026gt; 4.0 print(floor(3.7)) # =\u0026gt; 3.0 # You can import all functions from a module. # Warning: this is not recommended from math import * # You can shorten module names import math as m math.sqrt(16) == m.sqrt(16) # =\u0026gt; True # Import specific functions from a non-init module in a package from package.subPackage.subPackage1 import foo, bar # Python modules are just ordinary Python files. You # can write your own, and import them. The name of the # module is the same as the name of the file. # You can find out which functions and attributes # are defined in a module. import math dir(math) # If you have a Python script named math.py in the same # folder as your current script, the file math.py will # be loaded instead of the built-in Python module. # This happens because the local folder has priority # over Python\u0026#39;s built-in libraries. # Default module search is in the given order, we can add our own directories in sys.path  \u0026gt;\u0026gt;\u0026gt; import sys \u0026gt;\u0026gt;\u0026gt; sys.path [\u0026#39;\u0026#39;, \u0026#39;C:\\\\Python33\\\\Lib\\\\idlelib\u0026#39;, \u0026#39;C:\\\\Windows\\\\system32\\\\python33.zip\u0026#39;, \u0026#39;C:\\\\Python33\\\\DLLs\u0026#39;, \u0026#39;C:\\\\Python33\\\\lib\u0026#39;, \u0026#39;C:\\\\Python33\u0026#39;, \u0026#39;C:\\\\Python33\\\\lib\\\\site-packages\u0026#39;] # Reloading a module # This module shows the effect of multiple imports and reload #my_module.py print(\u0026#34;This code got executed\u0026#34;) #Now we see the effect of multiple imports. \u0026gt;\u0026gt;\u0026gt; import my_module This code got executed \u0026gt;\u0026gt;\u0026gt; import my_module \u0026gt;\u0026gt;\u0026gt; import my_module #Reloading with imp.reload(module_name) \u0026gt;\u0026gt;\u0026gt; import imp \u0026gt;\u0026gt;\u0026gt; import my_module This code got executed \u0026gt;\u0026gt;\u0026gt; import my_module \u0026gt;\u0026gt;\u0026gt; imp.reload(my_module) This code got executed \u0026lt;module \u0026#39;my_module\u0026#39; from \u0026#39;.\\\\my_module.py\u0026#39;\u0026gt; #################################################### ## 6. Classes and OOP #################################################### # We use the \u0026#34;class\u0026#34; statement to create a class class Human: # A class attribute. It is shared by all instances of this class species = \u0026#34;H. sapiens\u0026#34; # Basic initializer, this is called when this class is instantiated. # Note that the double leading and trailing underscores denote objects # or attributes that are used by Python but that live in user-controlled # namespaces. Methods(or objects or attributes) like: __init__, __str__, # __repr__ etc. are called special methods (or sometimes called dunder methods) # You should not invent such names on your own. def __init__(self, naam): # Assign the argument to the instance\u0026#39;s name attribute self.name = naam # Implicit decalration, and Initialization of property self._age = 0 # An instance method. All methods take \u0026#34;self\u0026#34; as the first argument  # as it is the first argument that is passed implicitly during the function call def say(self, msg): print(\u0026#34;{name}: {message}\u0026#34;.format(name=self.name, message=msg)) # Another instance method def sing(self): return \u0026#39;yo... yo... microphone check... one two... one two...\u0026#39; # A class method is shared among all instances # They are called with the calling class as the first argument @classmethod def get_species(cls): return cls.species # A static method is called without a class or instance reference @staticmethod def grunt(): return \u0026#34;*grunt*\u0026#34; # A property is just like a getter. # It turns the method age() into an read-only attribute of the same name. # There\u0026#39;s no need to write trivial getters and setters in Python, though. @property def age(self): return self._age # This allows the property to be set @age.setter def age(self, age): self._age = age # This allows the property to be deleted @age.deleter def age(self): del self._age # When a Python interpreter reads a source file it executes all its code. # This __name__ check makes sure this code block is only executed when this # module is the main program. if __name__ == \u0026#39;__main__\u0026#39;: # Instantiate a class i = Human(naam=\u0026#34;Ian\u0026#34;) i.say(\u0026#34;hi\u0026#34;) # \u0026#34;Ian: hi\u0026#34; j = Human(\u0026#34;Joel\u0026#34;) Human.say(j, \u0026#34;hello\u0026#34;) # \u0026#34;Joel: hello\u0026#34; # i and j are instances of type Human, or in other words: they are Human objects \u0026#39;\u0026#39;\u0026#39; object.func() #self is passed implicitly \u0026lt;-- OR --\u0026gt; Classname.func(object)\t#explicit object passing \u0026#39;\u0026#39;\u0026#39; # Call our class method i.say(i.get_species()) # \u0026#34;Ian: H. sapiens\u0026#34; # Change the shared attribute Human.species = \u0026#34;H. neanderthalensis\u0026#34; i.say(i.get_species()) # =\u0026gt; \u0026#34;Ian: H. neanderthalensis\u0026#34; j.say(j.get_species()) # =\u0026gt; \u0026#34;Joel: H. neanderthalensis\u0026#34; # Call the static method print(Human.grunt()) # =\u0026gt; \u0026#34;*grunt*\u0026#34; # Static methods can be called by instances too print(i.grunt()) # =\u0026gt; \u0026#34;*grunt*\u0026#34; # Update the property for this instance i.age = 42 # Get the property i.say(i.age) # =\u0026gt; \u0026#34;Ian: 42\u0026#34; j.say(j.age) # =\u0026gt; \u0026#34;Joel: 0\u0026#34; # Delete the property del i.age # i.age # =\u0026gt; this would raise an AttributeError #################################################### ## 6.1 Inheritance #################################################### # Inheritance allows new child classes to be defined that inherit methods and # variables from their parent class. # Using the Human class defined above as the base or parent class, we can # define a child class, Superhero, which inherits the class variables like # \u0026#34;species\u0026#34;, \u0026#34;name\u0026#34;, and \u0026#34;age\u0026#34;, as well as methods, like \u0026#34;sing\u0026#34; and \u0026#34;grunt\u0026#34; # from the Human class, but can also have its own unique properties. # To take advantage of modularization by file you could place the classes above in their own files, # say, human.py # To import functions from other files use the following format # from \u0026#34;filename-without-extension\u0026#34; import \u0026#34;function-or-class\u0026#34; from human import Human # Specify the parent class(es) as parameters to the class definition class Superhero(Human): # If the child class should inherit all of the parent\u0026#39;s definitions without # any modifications, you can just use the \u0026#34;pass\u0026#34; keyword (and nothing else) # but in this case it is commented out to allow for a unique child class: # pass # Child classes can override their parents\u0026#39; attributes species = \u0026#39;Superhuman\u0026#39; # Children automatically inherit their parent class\u0026#39;s constructor including # its arguments, but can also define additional arguments or definitions # and override its methods such as the class constructor. # This constructor inherits the \u0026#34;name\u0026#34; argument from the \u0026#34;Human\u0026#34; class and # adds the \u0026#34;superpower\u0026#34; and \u0026#34;movie\u0026#34; arguments: def __init__(self, name, movie=False, superpowers=[\u0026#34;super strength\u0026#34;, \u0026#34;bulletproofing\u0026#34;]): # add additional class attributes: self.fictional = True self.movie = movie # be aware of mutable default values, since defaults are shared self.superpowers = superpowers # The \u0026#34;super\u0026#34; function lets you access the parent class\u0026#39;s methods # that are overridden by the child, in this case, the __init__ method. # This calls the parent class constructor: super().__init__(name) # override the sing method def sing(self): return \u0026#39;Dun, dun, DUN!\u0026#39; # add an additional instance method def boast(self): for power in self.superpowers: print(\u0026#34;I wield the power of {pow}!\u0026#34;.format(pow=power)) if __name__ == \u0026#39;__main__\u0026#39;: sup = Superhero(name=\u0026#34;Tick\u0026#34;) # Instance type checks if isinstance(sup, Human): print(\u0026#39;I am human\u0026#39;) if type(sup) is Superhero: print(\u0026#39;I am a superhero\u0026#39;) # Get the Method Resolution search Order used by both getattr() and super() # This attribute is dynamic and can be updated print(Superhero.__mro__) # =\u0026gt; (\u0026lt;class \u0026#39;__main__.Superhero\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;human.Human\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;) # Calls parent method but uses its own class attribute print(sup.get_species()) # =\u0026gt; Superhuman # Calls overridden method print(sup.sing()) # =\u0026gt; Dun, dun, DUN! # Calls method from Human sup.say(\u0026#39;Spoon\u0026#39;) # =\u0026gt; Tick: Spoon # Call method that exists only in Superhero sup.boast() # =\u0026gt; I wield the power of super strength! # =\u0026gt; I wield the power of bulletproofing! # Inherited class attribute sup.age = 31 print(sup.age) # =\u0026gt; 31 # Attribute that only exists within Superhero print(\u0026#39;Am I Oscar eligible? \u0026#39; + str(sup.movie)) #################################################### ## 6.2 Multiple Inheritance #################################################### # Another class definition # bat.py class Bat: species = \u0026#39;Baty\u0026#39; def __init__(self, can_fly=True): self.fly = can_fly # This class also has a say method def say(self, msg): msg = \u0026#39;... ... ...\u0026#39; return msg # And its own method as well def sonar(self): return \u0026#39;))) ... (((\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: b = Bat() print(b.say(\u0026#39;hello\u0026#39;)) print(b.fly) # And yet another class definition that inherits from Superhero and Bat # superhero.py from superhero import Superhero from bat import Bat # Define Batman as a child that inherits from both Superhero and Bat class Batman(Superhero, Bat): def __init__(self, *args, **kwargs): # Typically to inherit attributes you have to call super: # super(Batman, self).__init__(*args, **kwargs) # However we are dealing with multiple inheritance here, and super() # only works with the next base class in the MRO list. # So instead we explicitly call __init__ for all ancestors. # The use of *args and **kwargs allows for a clean way to pass arguments, # with each parent \u0026#34;peeling a layer of the onion\u0026#34;. Superhero.__init__(self, \u0026#39;anonymous\u0026#39;, movie=True, superpowers=[\u0026#39;Wealthy\u0026#39;], *args, **kwargs) Bat.__init__(self, *args, can_fly=False, **kwargs) # override the value for the name attribute self.name = \u0026#39;Sad Affleck\u0026#39; def sing(self): return \u0026#39;nan nan nan nan nan batman!\u0026#39; if __name__ == \u0026#39;__main__\u0026#39;: sup = Batman() # Get the Method Resolution search Order used by both getattr() and super(). # This attribute is dynamic and can be updated print(Batman.__mro__) # =\u0026gt; (\u0026lt;class \u0026#39;__main__.Batman\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;superhero.Superhero\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;human.Human\u0026#39;\u0026gt;, # =\u0026gt; \u0026lt;class \u0026#39;bat.Bat\u0026#39;\u0026gt;, \u0026lt;class \u0026#39;object\u0026#39;\u0026gt;) # Calls parent method but uses its own class attribute print(sup.get_species()) # =\u0026gt; Superhuman # Calls overridden method print(sup.sing()) # =\u0026gt; nan nan nan nan nan batman! # Calls method from Human, because inheritance order matters sup.say(\u0026#39;I agree\u0026#39;) # =\u0026gt; Sad Affleck: I agree # Call method that exists only in 2nd ancestor print(sup.sonar()) # =\u0026gt; ))) ... ((( # Inherited class attribute sup.age = 100 print(sup.age) # =\u0026gt; 100 # Inherited attribute from 2nd ancestor whose default value was overridden. print(\u0026#39;Can I fly? \u0026#39; + str(sup.fly)) # =\u0026gt; Can I fly? False #################################################### ## 7. Advanced #################################################### # Generators help you make lazy code. def double_numbers(iterable): for i in iterable: yield i + i # Generators are memory-efficient because they only load the data needed to # process the next value in the iterable. This allows them to perform # operations on otherwise prohibitively large value ranges. # NOTE: `range` replaces `xrange` in Python 3. for i in double_numbers(range(1, 900000000)): # `range` is a generator. print(i) if i \u0026gt;= 30: break # Just as you can create a list comprehension, you can create generator # comprehensions as well. values = (-x for x in [1,2,3,4,5]) for x in values: print(x) # prints -1 -2 -3 -4 -5 to console/terminal # You can also cast a generator comprehension directly to a list. values = (-x for x in [1,2,3,4,5]) gen_to_list = list(values) print(gen_to_list) # =\u0026gt; [-1, -2, -3, -4, -5] # Decorators # In this example `beg` wraps `say`. If say_please is True then it # will change the returned message. from functools import wraps def beg(target_function): @wraps(target_function) def wrapper(*args, **kwargs): msg, say_please = target_function(*args, **kwargs) if say_please: return \u0026#34;{} {}\u0026#34;.format(msg, \u0026#34;Please! I am poor :(\u0026#34;) return msg return wrapper @beg def say(say_please=False): msg = \u0026#34;Can you buy me a beer?\u0026#34; return msg, say_please print(say()) # Can you buy me a beer? print(say(say_please=True)) # Can you buy me a beer? Please! I am poor :( "
},
{
	"uri": "https://hashdefine.netlify.app/bit/basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": "Bitwise Operators in C/C++ AND (\u0026amp;), OR (|), NOT (~), XOR (^), LEFT SHIFT (\u0026lt;\u0026lt;), RIGHT SHIFT (\u0026gt;\u0026gt;)\nThe left shift and right shift operators should not be used for negative numbers. If any of the operands is a negative number, it results in undefined behaviour. For example results of both -1 \u0026lt;\u0026lt; 1 and 1 \u0026lt;\u0026lt; -1 is undefined.\nAlso, if the number is shifted more than the size of integer, the behaviour is undefined. For example, 1 \u0026lt;\u0026lt; 33 is undefined if integers are stored using 32 bits. See this for more details.\n int In C/C++ int variable is 32-bits in size and can contain any integer between −231 and 231− 1.\nThe first bit in a signed representation is the sign of the number (0 for nonnegative numbers and 1 for negative numbers), and the remaining n − 1 bits contain the magnitude of the number. Two\u0026rsquo;s complement is used to represent negative numbers. Ex -\u0026gt; 2 = 0\u0026hellip;10 and -2 = 1\u0026hellip;10\nPeculiar Properties AND (\u0026amp;) - Used to \u0026ldquo;mask\u0026rdquo; bits, it can check for set bits and we can mask a number using another. OR (|) - Used to set bits. NOT (~) - 1\u0026rsquo;s complement of a number. XOR (^) - Exclusivity between two numbers' bits. Toggling bits. LEFT SHIFT (\u0026lt;\u0026lt;) - Left shift performed k times multiplies the number by 2k. RIGHT SHIFT (\u0026lt;\u0026lt;) - Right shift performed k times divides the number by 2k.\n2\u0026rsquo;s Complement of n = -n\n"
},
{
	"uri": "https://hashdefine.netlify.app/maths/basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": "Peano Axioms Link: https://en.wikipedia.org/wiki/Peano_axioms\nFundamental Theorem Of Arithmetic The fundamental theorem of arithmetic (FTA), also called the unique factorization theorem, states that every integer greater than 1 either is prime itself or is the product of a unique combination of prime numbers.\n1 is not considered prime because we lose uniqueness in factorization if we consider it a prime:\n25 = 5 * 5 * 1\r= 5 * 5 * 1 * 1\r= 5 * 5 * 1 * 1 * 1\r... no unique factorization\rUses We can easily calculate:\n No. of divisors No. of prime factors No. of even factors No. of odd factors Sum of even factors Sum of odd factors  Euclid\u0026rsquo;s Theorems Theorem 1: Euclid\u0026rsquo;s Division Lemma According to Euclid\u0026rsquo;s Division Lemma, if we have two positive integers a and b, then there exist unique integers q and r which satisfies the condition a = bq + r where 0 ≤ r \u0026lt; b. The basis of the Euclidean division algorithm is Euclid\u0026rsquo;s division lemma.\nTheorem 2: There are infinitely many primes Odd \u0026amp; Even Numbers  Even numbers are of the form 2k, and odd numbers are of the form 2k+1 for k = 0, 1, 2, 3\u0026hellip; Even numbers are also called Parity 0 integers and odd numbers are called Parity 1 integers.  if(n % 2 == 0) cout \u0026lt;\u0026lt; \u0026#34;Even\u0026#34;; else cout \u0026lt;\u0026lt; \u0026#34;Odd\u0026#34;; Efficient Way:\nif(n \u0026amp; 1) cout \u0026lt;\u0026lt; \u0026#34;Odd\u0026#34;; if(~ n \u0026amp; 1) cout \u0026lt;\u0026lt; \u0026#34;Even\u0026#34;; //else Big Integers Numbers larger than long long type can be stored and operated upon in an array or a vector.\n Problem: Factorial of Large Numbers Editorial Link: https://www.geeksforgeeks.org/factorial-large-number/\nArray Implementation:\n//Execution Time: 0.22 sec  #include\u0026lt;iostream\u0026gt; #define MAX 10000  using namespace std; void factorial(int); int multiply(int, int*, int); void factorial(int n) { int res[MAX]; res[0] = 1; int res_size = 1; for (int i = 2; i \u0026lt;= n; i++) //normal factorial formula =\u0026gt; 1 * 2 * 3 ... n-1 * n  { res_size = multiply(i, res, res_size); } for (int i = res_size - 1; i \u0026gt;= 0; i--) //result stored in res in reverse O(1) because inserting in beginning is O(n)  cout \u0026lt;\u0026lt; res[i]; } int multiply(int x, int* res, int res_size) { int carry = 0; for (int i = 0; i \u0026lt; res_size; i++) { int prod = res[i] * x + carry; res[i] = prod % 10; carry = prod / 10; } while (carry) //if there is a carry left after our res multiplication is finished  { res[res_size] = carry % 10; //set the carry as last digits of res  carry /= 10; res_size++; //and update the res_size  } return res_size; } int main() { int n; cin \u0026gt;\u0026gt; n; factorial(n); return 0; } Vector Implementation:\n//Execution Time: 0.49 sec  #include\u0026lt;iostream\u0026gt;#include\u0026lt;vector\u0026gt; using namespace std; int main() { ios::sync_with_stdio(0); cin.tie(0); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;int\u0026gt; res; res.push_back(1); for (int i = 2; i \u0026lt;= n; i++) //normal factorial formula  { int carry = 0; int prod = 0; for (int j = 0; j \u0026lt; res.size(); j++) //multiplying by individual digits  { prod = res[j] * i + carry; res[j] = prod % 10; carry = prod / 10; } while (carry) //take care of remaining carry  { res.push_back(carry % 10); carry /= 10; } } for (int i = res.size() - 1; i \u0026gt;= 0; i--) cout \u0026lt;\u0026lt; res[i]; //displaying in reverse, our number stored in vector res  cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } return 0; Binary Exponentiation Time = O(log n)\nan implies that we have to multiply a, exactly n-1 times with itself to evaluate it. Ex - 23 = 2 * 2 * 2.\nWe can do this with only order of log n multiplications by using binary representation of n as -\n2^13 = 2^(1101) = 2^8 * 2^4 * 2^0\rSince the binary representation of n has floor(log n) + 1 bits, hence O(log n) time.\nHalving and then squaring:\nlong binpow(long a, long b) { if(b == 0) return 1; long half = binpow(a, b/2); if(b\u0026amp;1) return half * half * a; else return half * half; } Squaring and then halving:\nlong binpow(long a, long b) { if(b == 0) return 1; long sq = a * a; if(b\u0026amp;1) return a * binpow(sq, b/2); else return binpow(sq, b/2); } For negative b and floating point a:\nfloat binpow(long a, long b)\t//float { if(b == 0) return 1; float half = binpow(a, b/2);\t//float  if(b % 2 == 0) return half * half; else { if(b \u0026gt; 0) return a * half * half; else return (half * half) / a;\t//this \t} } Calculating big exponential mods (abmod m) Mod every multiplication operation.\n//Iterative exponent mod (faster and efficient) long binpow(long a, long b, long m) { a %= m; long res = 1; while (b \u0026gt; 0) { if (b \u0026amp; 1) res = (res * a) % m; a = (a * a) % m; b \u0026gt;\u0026gt;= 1; } return res; } "
},
{
	"uri": "https://hashdefine.netlify.app/c++-language-specifics/basics/",
	"title": "Headers, Macros, and Compiler Flags",
	"tags": [],
	"description": "",
	"content": "One header to include every standard library #include\u0026lt;bits/stdc++.h\u0026gt; Also includes unnecessary stuff and increases length of code for compilation. Saves time during typing. Not portable as it\u0026rsquo;s not part of the C++ standard. Available in GCC but not in all others.  Macros and typedef #define LL long long #define ULL unsigned long long #define LD long double  #define MOD 1e9+7 OR\ntypedef long long LL; typedef unsigned long long ULL; typedef long double LD; Usage:\nLL a = 123; ULL b = 456; LD = 4.6775; Macro Functions and Raw Macros #define MAX(a,b) ((a)\u0026gt;(b)?(a):(b)) #define MIN(a,b) ((a)\u0026lt;(b)?(a):(b)) #define ABS(x) ((x)\u0026lt;0?-(x):(x))  #define si(n) scanf(\u0026#34;%d\u0026#34;,\u0026amp;n) #define sf(n) scanf(\u0026#34;%f\u0026#34;,\u0026amp;n) #define sl(n) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;n) #define slu(n) scanf(\u0026#34;%llu\u0026#34;,\u0026amp;n) #define sd(n) scanf(\u0026#34;%lf\u0026#34;,\u0026amp;n) #define ss(n) scanf(\u0026#34;%s\u0026#34;,n)  #define REP(i,n) for(int i=0;i\u0026lt;(n);i++) #define FOR(i,a,b) for(int i=(a);i\u0026lt;(b);i++) #define FORR(i,n) for(int i=(n);i\u0026gt;=0;i--) Compiler Flags g++ -std=c++11 -O2 -Wall test.cpp -o test This command produces a binary file test from the source code test.cpp. The compiler follows the C++11 standard (-std=c++11), optimizes the code (-O2), and shows warnings about possible errors (-Wall)\n"
},
{
	"uri": "https://hashdefine.netlify.app/c/gfg-c/tips/",
	"title": "Useful Stuff",
	"tags": [],
	"description": "",
	"content": "  After the pre-processing is over, all the undefined macros are initialized with default value 0.\n  All global stuff - pointers, variables of all types and with any modifiers are initialized with 0 (NULL for Pointers).\n  Inline Functions in C inline int square(int x) { return x*x; } int main() { int x = 36/square(6); printf(\u0026#34;%d\u0026#34;, x); return 0; } // OUTPUT: 1   A .i file is generated after pre-processing of a C program.\n  What is the use of #pragma once?\n  Used in a header file to avoid its inclusion more than once.\nAn Interesting Case #include\u0026lt;stdio.h\u0026gt;#define A -B #define B -C #define C 5  int main() { printf(\u0026#34;The value of A is %d\\n\u0026#34;, A); return 0; } Preprocessed File -\nint main() { printf(\u0026#34;The value of A is %d\\n\u0026#34;, - -5); return 0; } OUTPUT: 5\n The translator which performs macro calls expansion is called Macro pre-processor.  A Macro-processor is a program that copies a stream of text from one place to another, making a systematic set of replacements as it does so. A Dynamic linker is the part of an operating system that loads and links the shared libraries.    Line Splicing in C/C++ Lines terminated by a single / are spliced together with the next line very early in the process of translation.\n// C program to illustrate the concept of Line splicing. #include \u0026lt;stdio.h\u0026gt; int main() { // Line Splicing\\ \tprintf(\u0026#34;Hello GFG\\n\u0026#34;); printf(\u0026#34;welcome\u0026#34;); return (0); } OUTPUT: welcome\n Line splicing is used when defining a macro which contains multiple lines.  #include \u0026lt;stdio.h\u0026gt; #define MAX(a, b) \\ if(a\u0026gt;b) \\ printf(\u0026#34;%d\\n\u0026#34;, a); int main() { MAX(5, 2); } OUTPUT: 5\nHow Linkers Resolve Global Symbols Defined at Multiple Places? Link: https://www.geeksforgeeks.org/how-linkers-resolve-multiply-defined-global-symbols/\nScope Question C uses lexicographic/static scope that can be seen by the programmer as if he is substituting values in place of variables in code. Not determined at the runtime, through runtime stack.\nOctal number starts with a 0 int main() { int x = 032; printf(\u0026#34;%d\u0026#34;, x); return 0; } OUTPUT: 26\nSignals in C Link: https://www.geeksforgeeks.org/program-error-signals/\nReinitializing Global Variables in C C allows a global variable to be declared again only when the first declaration doesn\u0026rsquo;t initialize the variable.\nInitialization of global and static variables in C  In C, static and global variables are initialized by the compiler itself. Therefore, they must be initialized with a constant value. The above mentioned property does not apply to C++.  Scope vs. Linkage and Internal Linkage and External Linkage in C Link: https://www.geeksforgeeks.org/internal-linkage-external-linkage-c/\n(9/5) in C is and int Consider -\n#include \u0026lt;stdio.h\u0026gt; int main() { float c = 5.0; printf (\u0026#34;Temperature in Fahrenheit is %.2f\u0026#34;, (9/5)*c + 32); return 0; } OUTPUT: Temperature in Fahrenheit is 37.00\nConst Qualifier in C with Pointers Up Qualification / Down Qualification\nLink: https://www.geeksforgeeks.org/const-qualifier-in-c/\nVolatile Qualifier in C Objects declared as volatile are omitted from optimization because their values can be changed by code outside the scope of current code at any time. The system always reads the current value of a volatile object from the memory location rather than keeping its value in temporary register at the point it is requested, even if a previous instruction asked for a value from the same object.\nTypedef is a storage-specifier in C. The onlt storage specifier allowed inside a function parameter is register. sizeof() returns type size_t which is the largest unsigned type on that machine, usually unsigned long int sizeof() is done at compile time. Don\u0026rsquo;t use gets(), Format string vulnerabilities Link: https://www.geeksforgeeks.org/format-string-vulnerability-and-prevention-with-example/\nchar buf[8]; /* tiny buffer, easy to overflow */ printf(\u0026#34;What is your name?\\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;, buf); /* WRONG */ scanf(\u0026#34;%7s\u0026#34;, buf); /* RIGHT */ If the user enters a string longer than 7 characters (- 1 for the null terminator), memory behind the buffer buf will be overwritten. This results in undefined behavior. Malicious hackers often exploit this in order to overwrite the return address, and change it to the address of the hacker\u0026rsquo;s malicious code.\nCheck below note from Linux man page.\nNever use gets(). Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because gets() will continue to store characters past the end of the buffer, it is extremely dangerous to use. It has been used to break computer security. Use fgets() instead. Also see this post.\nImplicit type conversions always convert from lower(smaller) data type to higher(bigger) data type. Be careful when comparing signed int and unsigned int as signed will get converted to unisgned (2\u0026rsquo;s complement if overflow) and the sign will be lost. 0.1 is non-terminating recurring in binary, 0.5 is not, it is just 0.1 in binary. So, 0.5 is same in float as well as double but 0.1 is truncated to 23 bits after decimal in float and to 52 bits in double.\nDynamic Scoping Vs Static Scoping Link: https://stackoverflow.com/questions/19461503/dynamic-and-static-scoping-program-differences/19461570\nMIND BLOWING - Q:4, 5, 6, 10, 19, 20 Link: https://www.geeksforgeeks.org/c-language-2-gq/input-and-output-gq/\nOne more way to initialize array - int arr[50] = {0,1,2,[47]=47,48,49}; This is allowed in C as per standard. Basically, it’ll initialize arr[0], arr[1], arr[2], arr[47], arr[48] and arr[49] to 0,1,2,47,48 and 49 respectively. The remaining elements of the array would be initialized to 0. Q: 14, 15, 16, 17 Link: https://www.geeksforgeeks.org/c-language-2-gq/structure-union-gq/\n"
},
{
	"uri": "https://hashdefine.netlify.app/c/",
	"title": "C Programming",
	"tags": [],
	"description": "",
	"content": "C Programming Notes Short notes from various sources.\n"
},
{
	"uri": "https://hashdefine.netlify.app/c/c-dennis-ritchie/",
	"title": "C Programming by Dennis Ritchie",
	"tags": [],
	"description": "",
	"content": "The C Programming Language Short notes from the book by Brian W. Kernighan and Dennis M. Ritchie\n"
},
{
	"uri": "https://hashdefine.netlify.app/c/c-dennis-ritchie/2019-01-21-preface/",
	"title": "Preface",
	"tags": [],
	"description": "",
	"content": "What C gets right.  C is a general-purpose programming language. It is not a very high level language, nor a big one. It was originally designed for and implemented on the UNIX operating system. Very useful for writing operating system, compilers and system programs and hence it is also called a \u0026ldquo;systems programming language\u0026rdquo;. Many important ideas in C stem from BCPL and B. [BCPL -\u0026gt; B -\u0026gt; C] BCPL and B are \u0026ldquo;typeless\u0026rdquo; languages, they don\u0026rsquo;t have data types defined. On the other hand, C provides a variety of data types, as well as a hierarchy of derived data types like structure and union. Expressions are statements in C. Pointers provide machine-independent address arithmetic. Control flow constructions - for, while, if-else, etc. Functions in C might be in separate source files that can be compiled separately. Concept of Local(Automatic) and Global variables. Preprocessing to include libraries and to perform macro expansion.  Some Features of C  C provides no input/output facilities(READ or WRITE). C provides no operation to deal directly with composite objects such as strings and arrays. No storage allocation other than static definition and stack discipline provided by local variables of functions. There is no heap and garbage collection. C offers only straightforward, single-thread control flow: tests, loops, etc., but no parallel operation, multiprogramming, sync, or coroutines. C Programming language was standardized by ANSI (American National Standards Institute) in 1988. ANSI C also included definition of a library to accompany C. It specifies functions for accessing the operating system (Read/Write), formatted input and output, memory allocation, string manipulation, etc. This library is closely modeled on the \u0026ldquo;standard I/O library\u0026rdquo; of the UNIX system.  "
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-01-functions-and-arrays/",
	"title": "Functions and Arrays",
	"tags": [],
	"description": "",
	"content": "Precedence of Operators  Division and Multiplication has same priority/precedence - to resolve, we use associativity (Left-to-Right).  Arrays  Arrays are Garbage Declared, Zero Initialized. Bound Checking is not done in C++, no compilation error when ArrayOutOfBound.  Errors  Logical Errors - Difficult to Debug. Semantics Errors - aka Compile Time Errors. Runtime Errors - Pass the Compilation but program fails during Runtime.like dividing by 0.  Undefined Behaviour No behaviour can be defined beforehand even in the same environment.\nImplementation Defined e.g. Data types size difference in different environments, same behaviour in one environment.\nLAW-1 : Whenever accessing any element of an array \u0026ldquo;make sure\u0026rdquo; that the element exists in the array. "
},
{
	"uri": "https://hashdefine.netlify.app/linux-and-tools/awk/",
	"title": "Awk",
	"tags": [],
	"description": "",
	"content": "Lorem Ipsum.\n"
},
{
	"uri": "https://hashdefine.netlify.app/regex/notes/",
	"title": "Notes",
	"tags": [],
	"description": "",
	"content": "Regex pronunciation: \u0026ldquo;Redj-ex\u0026rdquo;\nRegex in programming languages C++11 onwards (\u0026lt;regex\u0026gt; header), Python, Java, Javascript, PHP, Java, etc\u0026hellip;\nC++ Regex is written in the form of a string inside double-quotes (\u0026quot;\u0026quot;)\nregex foo(\u0026#34;Geek[a-zA-Z]+\u0026#34;); //foo is the object of regex Javascript \u0026amp; Ruby Regex is written within forward slashes (/regex/)\nvar str = \u0026#39;cat\u0026#39;; if (str.match(/a/)) { console.log(\u0026#34;matched \u0026#39;a\u0026#39;\u0026#34;); } if (str.match(/x/)) { console.log(\u0026#34;matched \u0026#39;x\u0026#39;\u0026#34;); }  Basic Match Example#0\n Meta Characters Reserved chars. Use \\ to escape. Ex - \\., *, etc\u0026hellip;\n Dot . Matches a single character only (except newline char \\n)Example#0Example#1\n Character Set aka Character ClassSpecified inside square brackets []\n No Space : Example#0 Hyphen : Example#1 Both of the above: Example#2  A dot . inside a Char class means a literal dot .\n Example#0 Example#1  Negated Character Set Any char/charset written within [] and preceded by ^ will be negated.\n [^c]ar : Example#0 [^ctpj] : Example#1   Quantifiers Repetitions Symbols *, +, and ?\n  Asterisk * : No. of occurances of char/charset preceding it must be \u0026gt;=0\n On single char : Example#0 On charset : Example#1    Plus + : No. of occurances of char/charset preceding it must be \u0026gt;=1\n On single char : Example#0 On charset : Example#1    Question Mark ?\n Makes the preceding character optional.It matches zero or one instance of the preceding character. If character is there, it matches whole word, if not, then it matches remainning word other than optional char. Example#0    Ranges aka \u0026ldquo;Quantifiers\u0026rdquo;, written only post char/charset.Can be applied to both Char and CharsetUsage Styles : {n1,n2}, {n1,}, {n}\n Capturing Groups Uses () to create a group and capture the match. Ex - (ab)*Can use altenations inside of it as (c|r|m|e|f)at: Example#0Grouping: Example#1\nNon-Capturing Groups Uses ? followed by a : within () to create a group but not capture the match. Ex - (?:c|r|m|e|f)at\n Alternation | Works like logical OR operator\nAns: In the above case it\u0026rsquo;s the same. But, alternations work at expression level and charset at char level only. We can alter between expressions (multiple-chars/string) using | as abhi(shek|manyu) but not as abhi[shekmanyu].\n Escaping Special Characters Prepend a special/meta character with a backslash \\ to use it as a matching char.\n Anchors Caret ^ and Dollar $\n Caret ^ used to specify start position of the input string. It does not matches the character but position at the start of the input. Ex - String input that starts with T is matched by ^T Dollar $ used to specify used to specify start position of the input string. It does not matches the character but position at the end of the input. Ex - String that ends with e is matched by e$ \\b and \\B are non-character consuming anchors too.   Shorthand Character Sets    Shorthand Description     . Any character except new line   \\w Matches alphanumeric characters: [a-zA-Z0-9_]   \\W Matches non-alphanumeric characters: [^\\w]   \\d Matches digits: [0-9]   \\D Matches non-digits: [^\\d]   \\s Matches whitespace characters: [\\t\\n\\f\\r\\p{Z}]   \\S Matches non-whitespace characters: [^\\s]     Word Boundaries Denoted by \\b, in most regex dialects, is a position between \\w and \\W (non-word char), or at the beginning or end of a string if it begins or ends (respectively) with a word character ([0-9A-Za-z_]). So, in the string \u0026ldquo;-12\u0026rdquo; , it would match before the 1 or after the 2. The dash is not a word character.Example#0 Note that ^ and $ are also word boundries as start and end of input respectively.Also note that \\band \\B matches without consuming any char. Non-Word Boundry:: Matches, without consuming any characters, at the position between two characters matched by \\w. Example#1\n Backreferences When we make a capture group, regex engine references the result implicitly in a first occurance order and we can use that reference with \\ref_num to use it again. Example#0 Note that capturing is neccessary for backreferening to happen and work. Also note that backreferences match the same text as most recently matched by the capturing group they reference (i.e. its resultant match 33) and not just the group pattern \\d\\d.Example#1\nBackreferences to failed groups: Concept and important distinction here. First example is \u0026ldquo;b participated but failed, the result was then captured using ()\u0026rdquo;, second example is \u0026ldquo;never participated at all\u0026rdquo; since the entire group was optional, it skipped checking match for (b) group altogether.\n Branch Reset Groups* Branch reset group is supported by Perl, PHP, Delphi and R Syntax:(?|(regex1)|(regex2)|(regex3)|.....) Explanation: It allows us to branch/choose from among regex1, regex2, regex3 capture groups, any one, capture the result one time and reference it later on. Note that the (?|regex) itself counts as one occurance of the chosen matched single capture group. Example#0\n Forward References* Forward reference is supported by JGsoft, .NET, Java, Perl, PCRE, PHP, Delphi and Ruby Explanation: It allow you to use a backreference to a group that appears later in the regex. Forward references are obviously only useful if they’re inside a repeated group.Example#0Example#1\n Lookarounds Also called \u0026ldquo;Assertions\u0026rdquo;. Two types: Lookaheads and Lookbehinds. They are non-capturing.    Symbol Name Description     (?= ) Positive Lookahead Used on RHS of main regex   (?! ) Negative Lookahead \u0026quot;   (?\u0026lt;= ) Positive Lookbehind Used on LHS of main regex   (?\u0026lt;! ) Negative Lookbehind \u0026quot;     Flags Also known as \u0026ldquo;Modifiers\u0026rdquo;. Heavily dependent on regex engine being used.    Flag Description     i Case insensitive: Match will be case-insensitive.   g Global Search: Match all instances, not just the first.   m Multiline: Anchor meta characters work on each line. By default, the $ is at the end of the whole input, but m flag forces it at every line end     Greedy vs Lazy Matching Use ? with any of the six quantifiers to match in a lazy way. Good explaination here. Good example here.\n "
},
{
	"uri": "https://hashdefine.netlify.app/rdbms/mysql/",
	"title": "MySQL",
	"tags": [],
	"description": "",
	"content": "SQL (Structured Query Language)  Always case-insensitive (even table and attributes names) Semicolon ; to indicate command termination are mandatory in MySQL terminal # and -- (single-line comments) /* */ (multi-line commnents) RDBMS language  Glossary  Attributes, Fields (Columns), Degree (no. of attributes) Tuple (Rows), Cardinality (no. of tuples) DDL (create, alter, truncate) DML (insert, delete, update) DCL (grant, revoke) DQL (select) TCL (rollback, commit, savepoint)  Storage Engines https://www.mysqltutorial.org/understand-mysql-table-types-innodb-myisam.aspx\nDefault is: InnoDB\nLogging into the MySQL Server $ mysql -u username -p Enter Password: ******** Creating and Dropping DB CREATE DATABASE [IF NOT EXISTS] db_name; DROP DATABASE [IF EXISTS] db_name; Importing an external DB SOURCE c:\\path\\to\\db_name.sql\nListing all available DB SHOW DATABASES;\nSelecting a DB to use USE db_name;\nData Types https://www.tutorialspoint.com/mysql/mysql-data-types.htm\nCREATE TABLE CREATE TABLE [IF NOT EXISTS] table_name( column_1_definition, column_2_definition, ..., table_constraints ) ENGINE=storage_engine; CREATE TABLE t_name( serial_no INT NOT NULL AUTO_INCREMENT, emp_id INT NOT NULL, emp_name VARCHAR(25) NOT NULL, doj DATE, PRIMARY KEY (emp_id) --single col only, multiple =\u0026gt; CONSTRAINT PK_Person PRIMARY KEY (ID,LastName) ); CREATE TABLE TestTable AS SELECT customername, contactname FROM customers; (*Creating one table from another by projection, this copies rows too)\nCREATE TABLE emp1 AS SELECT * FROM emp WHERE 1=2; --no data from where clause (*Copying only the schema)\nDROP TABLE DROP TABLE IF EXISTS t_name, t2_name; or simply DROP TABLE t_name; (delete data as well as schema)\nTRUNCATE TRUNCATE TABLE t_name; (delete all data but keep schema)\nDESCRIBE DESCRIBE table_name; (display the schema of the table)\nALTER TABLE ALTER TABLE t_name ADD c_name varchar(10) [ FIRST | AFTER column_name], ADD c2_name varchar(100) [ FIRST | AFTER column_name]; ALTER TABLE t_name MODIFY c_name varchar(20), MODIFY c2_name varchar(90); ALTER TABLE t_name CHANGE COLUMN old_name new_name [ FIRST | AFTER column_name]; ALTER TABLE t_name DROP COLUMN c_name; ALTER TABLE t_name RENAME TO new_t_name; RENAME TABLE RENAME TABLE old_table_name TO new_table_name;\n(*for renaming temporary tables use ALTER TABLE RENAME TO)\nINSERT INTO INSERT INTO t_name(attrib1, attrib2, ... attribN) VALUES (v11,v12,...), (v21,v22,...), ... (vnn,vn2,...); -- No need to specify if filling all attributes  INSERT INTO t_name VALUES (value1, value2, ... valueN); SELECT SELECT [DISTINCT] Attribute_List FROM T1,T2…TM [WHERE condition1 [AND/OR... condition2]] [GROUP BY (Attributes)[HAVING condition]] [ORDER BY(Attributes)[ASC/DESC]]; (Uses ASC by default)\nOperators in WHERE  Relational (=, !=, \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;=)  condition1 AND/OR/NOT condition2 \u0026hellip; and so on..  LIKE SELECT * FROM Customers WHERE City LIKE 's%'; (% = *, _ = .)  BETWEEN, NOT BETWEEN SELECT * FROM Products WHERE Price BETWEEN 50 AND 60;  IN/NOT IN SELECT * FROM Customers WHERE City IN ('Paris','London'); (Ex - IN (subquery))  IS NULL/IS NOT NULL SELECT column_names FROM table_name WHERE column_name IS NULL;   SELECT field1, field2,...fieldN FROM table_name1, table_name2... [WHERE Clause] [OFFSET M ][LIMIT N] SELECT field1, field2,...fieldN FROM table_name1, table_name2... [WHERE Clause] LIMIT [offset_value,] limit_value UPDATE UPDATE table_name SET field1 = value1, field2 = value2 [WHERE Clause] DELETE DELETE FROM table_name [WHERE Clause] Aggregate Functions  MIN(), MAX() SELECT MIN(marks_maths) FROM RESULT-2020 WHERE BATCH='OP1' SELECT MIN(Price) AS SmallestPrice FROM Products;  COUNT(), AVG(), SUM()  ALIAS # Column Aliases SELECT price FROM table AS cost; # Table Aliases SELECT item, price FROM table t; JOINS  Inner Outer  Left Right Full   Self  https://www.mysqltutorial.org/mysql-join/ https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/ https://www.geeksforgeeks.org/sql-join-cartesian-join-self-join/\nUNION, UNION ALL, INTERSECT, MINUS SELECT column_name(s) FROM table1 UNION/UNION ALL SELECT column_name(s) FROM table2; (* UNION ALL keeps duplicate tuples whereas UNION does not)\n Each SELECT statement within UNION must have the same number of columns The columns must also have similar data types The columns in each SELECT statement must also be in the same order  SELECT City, Country FROM Customers WHERE Country=\u0026#39;Germany\u0026#39; UNION SELECT City, Country FROM Suppliers WHERE Country=\u0026#39;Germany\u0026#39; ORDER BY City;\t--applies to whole union-ed table GROUP BY SELECT COUNT(CustomerID), Country FROM Customers GROUP BY Country (we can skip Country from projection but that doesn\u0026rsquo;t make any sense)\nHAVING The WHERE clause places conditions on the selected columns, whereas the HAVING clause places conditions on groups created by the GROUP BY clause. We can\u0026rsquo;t have HAVING without GROUP BY.\nSELECT COUNT(CustomerID), Country FROM Customers GROUP BY Country HAVING COUNT(CustomerID) \u0026gt; 5 ORDER BY COUNT(CustomerID) DESC; EXISTS The EXISTS operator returns true if the subquery returns one or more records, else false.\nSELECT SupplierName FROM Suppliers WHERE EXISTS (SELECT ProductName FROM Products WHERE Products.SupplierID = Suppliers.supplierID AND Price \u0026lt; 20); ANY, ALL They return actual value if even one match is there in subquery and all matches in subquery respectively.\nSELECT ProductName FROM Products WHERE ProductID = ANY (SELECT ProductID FROM OrderDetails WHERE Quantity = 10); REGEXP SELECT name FROM person_tbl WHERE name REGEXP \u0026#39;ok$\u0026#39;; SELECT INTO Insert attributes into new table from an existing one.\nSELECT column1, column2, column3, ... INTO newtable [IN externaldb] FROM oldtable WHERE condition; INSERT INTO SELECT Insert data from matching corresponding attributes from one table to another.\nINSERT INTO table2 (column1, column2, column3, ...) SELECT column1, column2, column3, ... FROM table1 WHERE condition; CASE CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 WHEN conditionN THEN resultN ELSE result END; SELECT OrderID, Quantity, CASE WHEN Quantity \u0026gt; 30 THEN \u0026#39;The quantity is greater than 30\u0026#39; WHEN Quantity = 30 THEN \u0026#39;The quantity is 30\u0026#39; ELSE \u0026#39;The quantity is under 30\u0026#39; END AS QuantityText FROM OrderDetails; DCL savepoint save_name; rollback to save_name; rollback; --rolls back to latest savepoint commit; --cannot rollback after a commit SQL Constraints  PRIMARY KEY (Not Null + Unique)  CREATE TABLE demo( name varchar(20), id int NOT NULL PRIMARY KEY\t--column level since single PK ); CREATE TABLE demo( name varchar(20), id int NOT NULL, [CONSTRAINT key_alias] PRIMARY KEY(name, id) --table level since multiple PK, single also allowed ); ALTER TABLE demo ADD PRIMARY KEY(id);  FOREIGN KEY (Uniquely identifies a row/record in another table) UNIQUE NOT NULL CHECK (Ensures that all values in a column satisfies a specific condition) CHECK(salary \u0026gt;= 3) DEFAULT (Sets a default value for a column when no value is specified) DEFAULT \u0026quot;John Doe\u0026quot; INDEX, ENUM  CREATE TABLE t_name ( col1 int NOT NULL UNIQUE, col2 varchar(255) DEFAULT 3, col3 varchar(255), col4 int, ); Functions FK Constraint, Joins, Built-in Functions, Normalization "
},
{
	"uri": "https://hashdefine.netlify.app/nosql/mongodb/",
	"title": "MongoDB",
	"tags": [],
	"description": "",
	"content": "Lorem Ipsum.\n"
},
{
	"uri": "https://hashdefine.netlify.app/python/oops/",
	"title": "OOP",
	"tags": [],
	"description": "",
	"content": "\u0026#39;\u0026#39;\u0026#39; Class Object Object Variable Class Attribute/Data member (Static variable) Instance Methods Class Methods Static Methods Instance Instantiation self -\u0026gt; instance reference cls -\u0026gt; class reference Inner Classes \u0026#39;\u0026#39;\u0026#39; # The need for \u0026#34;self\u0026#34;  class Car: pass obj = Car()\t#Insantiation, Instance = obj obj.brand = \u0026#39;Audi\u0026#39; obj.type = \u0026#39;Sports\u0026#39; obj.price = 5000000 print(obj.brand, obj.type, obj.price)\t# =\u0026gt; Audi Sports 5000000 # We can \u0026#39;automate\u0026#39; this variable creation using \u0026#34;self\u0026#34; to refer to calling object  class Car: def __init__(self): self.brand = \u0026#39;Audi\u0026#39; self.type = \u0026#39;Sports\u0026#39; self.price = 5000000 obj = Car() print(obj.brand, obj.type, obj.price)\t# =\u0026gt; Audi Sports 5000000 # First parameter is always the instance of the calling object (i.e. self), it is passed implicitly # Variables (Class vars and Instance vars) class Car: wheels = 4 # class variable def __init__(self, br): self.brand = br #instance variables self.year = 1999 def foobar(self): print(self.year) obj = Car(\u0026#39;BMW\u0026#39;)\t# Instance Methods = Calling with two visually different but functionally excatly the same syntaxes obj.foobar() # =\u0026gt; 1999 Car.foobar(obj)\t# =\u0026gt; 1999 # Class attribute \u0026#34;wheels\u0026#34; can be accessed by both class name and via object  print(Car.wheels)\t# =\u0026gt; 4 print(obj.wheels)\t# =\u0026gt; 4 # Class Methods class A: @classmethod\t# required to access via A.foobar() def foobar(cls):\t#can also use self insted of cls, it has first parameter as classname implicitly print(\u0026#39;foobar\u0026#39;) obj = A() # Can be accessed by both class name and object just like class attributes A.foobar()\t# =\u0026gt; foobar obj.foobar()\t#=\u0026gt; foobar # Static methods class A: @staticmethod\tdef foobar():\t#not supposed to have any class or object instance arguments print(\u0026#39;foobar\u0026#39;) obj = A() # Can be accessed by both class name and object just like class attributes A.foobar()\t# =\u0026gt; foobar obj.foobar()\t#=\u0026gt; foobar # Inner Classes -\u0026gt; Classes inside other classes class A: name = \u0026#39;Apple\u0026#39; def __init__(self): self.objB = self.B()\t#can create object of inner class in outer class class B:\t#inner class name = \u0026#39;Ball\u0026#39; objA = A() print(objA.objB.name)\t# =\u0026gt; Ball #creating object of B outside A anotherObjB = A.B() print(anotherObjB.name)\t# =\u0026gt; Ball # Inheritence \u0026#39;\u0026#39;\u0026#39; Single Mutli-Level Multiple Constructors in Inheritence Method Resolution Order(MRO) \u0026#39;\u0026#39;\u0026#39; \u0026#34;\u0026#34;\u0026#34; Superclass | Subclass Subclass can access all vars and methods of super but not vice-versa. \u0026#34;\u0026#34;\u0026#34; # Single Inheritence class A: pass class B(A): pass # Multi-level Inheritence class A: pass class B(A): pass class C(B): pass\t# Multiple Inheritence class A: pass class B: pass class C(A,B): pass # Constructor behaviour in Inheritence -\u0026gt; By default only the calling object\u0026#39;s class __init__ is called class A: def __init__(self): print(\u0026#39;Const of A\u0026#39;) class B(A): def __init__(self): print(\u0026#39;Const of B\u0026#39;) obj = B()\t# =\u0026gt; Const of B # If we want to call __init__ of A too, use \u0026#34;super()\u0026#34;\u0026#34; class A: def __init__(self): print(\u0026#39;Const of A\u0026#39;) class B(A): def __init__(self): super().__init__()\t#redirect to const of A first print(\u0026#39;Const of B\u0026#39;) obj = B() \u0026#39;\u0026#39;\u0026#39; Const of A Const of B \u0026#39;\u0026#39;\u0026#39; # In multiple inheritence -\u0026gt; we can\u0026#39;t use super(), can we? Yes, left to right order is followed, i.e. if  class C(A, B): pass #then only the constructor of A is called with super() call #this applies to other class and object methods too and is called Method Resolution Order (MRO) # Polymorphism - 4 ways in Python  \u0026#39;\u0026#39;\u0026#39; Duck Typing Operator Overloading Method Overloading Method Overiding \u0026#39;\u0026#39;\u0026#39; # Duck Typing -\u0026gt; Can have many diffrent classes and their objects can be passed to functions accessing a common method that all of them have. class A: my_attr = \u0026#39;Anything\u0026#39; def foo(self): print(\u0026#39;foobar\u0026#39;) class B: def foo(self): print(\u0026#39;boofar\u0026#39;) objA = A() objB = B() def printMe(obj):\t#external method obj.foo() printMe(objA)\t# don\u0026#39;t care if we are passing any class object as long as it has foo() method  printMe(objB) # Operator Overloading -\u0026gt; Customizing(overloading) default built-in operators for performing operations on class objects # Default operators\u0026#39; built-in actions: a = 3 b= 4 print(a + b) #int.__add__(a, b) print(a - b) #int.__sub__(a, b) print(a * b) #int.__mul__(a, b) print(a \u0026gt; b) #int.__gt__(a, b) # Create methods that overload these in class and you can use +, -, *, \u0026gt;, etc.. class A: marks = 40 def __add__(self, any_var): return self.marks + any_var.marks class B: marks = 50 objA = A() objB = B() print(objA + objB)\t# =\u0026gt; 90, not an error # Method Overloading (can\u0026#39;t create two functions with same name in same scope in Python) # Use *vargs or default arguments for this # Method Overriding class A: def show(self): print(\u0026#39;A\u0026#39;) class B(A): def show(self): print(\u0026#39;B\u0026#39;) objB = B() objB.show() # =\u0026gt; B #B.show() overrides A.show()  "
},
{
	"uri": "https://hashdefine.netlify.app/bit/applications/",
	"title": "Applications",
	"tags": [],
	"description": "",
	"content": "Applications  Finding single element that occurs odd number of times in an array. Detect if two integers have opposite signs. (x ^ y) \u0026lt; 0 Adding 1 to number without using + operator. xPlusOne = -(~x), since ~x = -(x+1) holds. Turn off the rightmost set bit. n \u0026amp; (n - 1) Checking is number is power of 4. single set bit having even number of 0s on its right side Checking is number is power of 2. n \u0026amp; (n - 1) will be 0 Modulus division by a number (n) of the form 2k (d). n \u0026amp; (d-1), so in place of (n % 4) we can write (n \u0026amp; 3). Rotating bits. Left = n \u0026lt;\u0026lt; k | n \u0026gt;\u0026gt; (32-k) and Right = n \u0026gt;\u0026gt; k | n \u0026lt;\u0026lt; (32-k) Multiplying with 3.5. 2x + x + x/2 = (x \u0026lt;\u0026lt; 1) + x + (x \u0026gt;\u0026gt; 1) Multiplying with 7. 8x - x = (x \u0026lt;\u0026lt; 3) - x Counting bits to be flipped to convert A to B (Bit Difference). This is number of set bits in A ^ B. Finding position of rightmost set bit. Do 2's complement, \u0026amp; with original number, take log2(ANDresult) = log2(n \u0026amp; -n) + 1 Finding Binary Representation of a decimal number. Link Swap two numbers without using a temporary variable. Swap two nibbles in a byte. ((x \u0026amp; 0x0F) \u0026lt;\u0026lt; 4 | (x \u0026amp; 0xF0) \u0026gt;\u0026gt; 4 ) Turn off a particular bit. n \u0026amp; ~(1 \u0026lt;\u0026lt; (k - 1) (one based indexing from LSB) Toggle particular bit. n ^ (1 \u0026lt;\u0026lt; (k - 1)) (one based indexing from LSB) Russian Peasant (Multiply two numbers using bitwise operators). Link Check if two numbers are equal. a ^ b = 0 only if a, b are equal Find XOR of two number without using XOR operator. (x | y) \u0026amp; (~x | ~y) XOR from [1 to n] efficiently. Link Toggling Case of characters in a String. str[i] ^= 32   "
},
{
	"uri": "https://hashdefine.netlify.app/c++-language-specifics/useful-functions/",
	"title": "Useful Functions",
	"tags": [],
	"description": "",
	"content": "Faster I/O printf/scanf is faster than cout/cin, but we can make cout/cin as faster by using below trick or simply use print/scanf in C++.\n ios_base::sync_with_stdio(false); cin.tie(NULL); OR\nios::sync_with_stdio(0); cin.tie(0);  Note that the newline \u0026ldquo;\\n\u0026rdquo; works faster than endl, because endl always causes a flush operation.\n Explanation: Every C++ standard stream is synced with the corresponding standard C stream before program starts. We can stop synchronization by passing argument to ios::sync_with_stdio() as 0 or false. The function tie() ensures flushing cout before every cin and we stop it by passing 0 or NULL.\nWriting to Files Just add the below lines at the beginning and proceed using standard I/O streams (cin and cout).\nfreopen(\u0026quot;input.txt\u0026quot;, \u0026quot;r\u0026quot;, stdin);\rfreopen(\u0026quot;output.txt\u0026quot;, \u0026quot;w\u0026quot;, stdout);\rmemset()  To set all values in a memory block to a specified value. It works bytewise, so we can only set values 0, -1, and true/false. Signature: void * memset ( void * ptr, int value, size_t num );  #include \u0026lt;bits/stdc++.h\u0026gt; #define FR(n) for(int i=0;i\u0026lt;n;i++)  using namespace std; int main() { int hash[26]; memset(hash, 0, sizeof(hash));\t//no need of for loop to set values  FR(26) cout \u0026lt;\u0026lt; hash[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t//0 0 0 0 0 0 ... 26 times  return 0; } GCD __gcd(a, b) in \u0026lt;algorithms\u0026gt;\nLCM Since C++17, std::lcm(a, b) in \u0026lt;numeric\u0026gt;\nSort sort(arr, arr+n)\nsort(v.begin(), v.end()\nSwap swap(a, b)\nMinimum and Maximum min(a, b) and max(a, b)\n"
},
{
	"uri": "https://hashdefine.netlify.app/maths/gcd/",
	"title": "GCD, LCM, and Euclidean Algorithm",
	"tags": [],
	"description": "",
	"content": "GCD GCD (Greatest Common Divisor) or HCF (Highest Common Factor) of n numbers n1, n2, n3, \u0026hellip; is defined as largest number g which divides all of them. Ex - GCD(15, 20) = 5, GCD(6,7) = 1.\nProperties   GCD(a, b) \u0026lt;= min(a, b)\n  GCD(a, b) \u0026gt;= 1\n  GCD(a, b) = GCD(|a|, |b|)\n  For any non-zero m ∈ Z, GCD(ma, mb) = |m| * GCD(a, b)\n  GCD(a, b) = GCD(a + b, b) = GCD(a - b, b) = GCD(a * b, b) (may or may not be equal to GCD(a/b, b))\n  GCD(a, b) = GCD(a - kb, b), where k = 0, 1, 2 ...\n  GCD(a, b) = GCD(a % b, b) while a \u0026gt; b (Euclid\u0026rsquo;s Theorem) (Since 6 is true, modulo is nothing but remaining after repeated subtraction of b from a (aka division =\u0026gt; a - (a / b) * b)\n  Solutions Prime Factorization Product of smallest powers of only common factors.\nBrute Force Time = O(min(a, b))\nSince property 1, start from 1 and divide each number by a and b, keep track of the largest number that divides both and gcd will be that number after the loop finishes.\nBased on GCD(a, b) = GCD(a - b, b) This algorithm again takes O(max(a, b)) time in worst case because if b = 1, then, we have to call function a times.\nThis is basically reduction of larger number into smaller by subtraction.\n//Recursive int GCD(int a, int b){ if(a == 0) return b; if(b == 0) return a; if(a == b) return a; if(a \u0026gt; b) return GCD(a - b, b); else return GCD(a, b - a);\t} //Iterative int GCD(int a, int b){ while(a != b) { if(a \u0026gt; b) a = a - b; else b = b - a; } return a; } Based on Euclid\u0026rsquo;s theorem Time = O(log(min(a, b)))\nWorst Case = a and b are consecutive numbers in fibonacci sequence\nWorst Case recursive calls = n-2\nThis is basically reduction of larger number into smaller by modulo.\n//Recursive int GCD(int a, int b) { if(b == 0) return a; return GCD(b, a % b);\t//don\u0026#39;t forget to swap } //Iterative int GCD(int a, int b) { while(b) { a %=b; swap(a, b); } return a; } LCM LCM (Lowest Common Multiple) l of numbers n1, n2, n3, \u0026hellip; is defined as them least number that is completely divisible by all the numbers. Ex - LCM(6, 12) = 12, LCM(5, 18) = 90.\nProperties  LCM(a, b) \u0026gt;= max(a, b) a * b = LCM(a, b) * GCD(a, b) (true for only two numbers)  Solutions Prime Factorization Product of largest powers of all factors.\nBrute Force Since property 1, start from max(a, b) and take all its subsequent multiples and the first number that divides min(a, b) will be our answer.\nint LCM(int a, int b) { int lar = max(a, b); int small = min(a, b); for (int i = lar; ; i += lar) { if (i % small == 0) return i; } } Using GCD Use formula in property 2 above.\nEuclidean Algorithm Based on the fact that: If a, b, q, r are integers such that a = b * q + r, then gcd(a, b) = gcd(b, r).\ngcd(a, b) =\ta,\tif b = 0\rgcd(b, a % b)\totherwise\rExtended Euclidean Algorithm EA can find gcd(a, b), but EEA can also find coefficients that exist x and y such that: x * a + y * b = gcd(a, b) (Bézout\u0026rsquo;s identity (or Bézout\u0026rsquo;s lemma))\nx = y1\ry = x1 - floor(a / b) * y1\rProof: https://www.cp-algorithms.com\nImplementation\nint gcd (int a, int b, int \u0026amp;x, int \u0026amp;y) { if (b == 0) { x = 1; y = 0; return a; } int x1, y1; int d = gcd (b, a%b, x1, y1); x = y1; y = x1 - (a / b) * y1; return d; } References  https://procoderforu.com/gcd/ https://www.geeksforgeeks.org/c-program-find-gcd-hcf-two-numbers/  https://cp-algorithms.com i. Euclidean Algorithm ii. Extended Euclidean Algorithm Brillant Wiki i. GCD ii. LCM iii. Euclidean Algorithm iv. Bézout\u0026rsquo;s identity v. Extended Euclidean Algorithm  "
},
{
	"uri": "https://hashdefine.netlify.app/c/gfg-c/",
	"title": "C - GeeksforGeeks",
	"tags": [],
	"description": "",
	"content": "C Programming - GeeksforGeeks A collection of ultra short notes and jots from GeeksforGeeks.\nLink - https://www.geeksforgeeks.org/c-programming-language/\n"
},
{
	"uri": "https://hashdefine.netlify.app/c++/",
	"title": "C++ Programming",
	"tags": [],
	"description": "",
	"content": "Short Notes The C++ Programming Language Powerful and Elegant.\n"
},
{
	"uri": "https://hashdefine.netlify.app/c/c-dennis-ritchie/2019-01-21-c-programming-chapter-1/",
	"title": "A Tutorial Introduction",
	"tags": [],
	"description": "",
	"content": "  main() - The program begins executing at the beginning of main and there must be atleast one in the program.\n  \u0026quot;Hello, world\u0026quot; - a sequence of characters in double quotes is called a string constant or character string or string literal.\n  /*.....*/ - Multi-line comment.\n  The above sizes are machine-dependent.\n  Storing foating point number in int truncates it (i.e. strores only the integer part).\n  In the below code, % followed by character indicates where the arguments are to be substituted.\n  printf(\u0026#34;%d \\n\u0026#34;, num);\t//integer  printf(\u0026#34;%ld \\n\u0026#34;, num);\t//long integer  printf(\u0026#34;%f \\n\u0026#34;, num);\t//float, double  printf(\u0026#34;%c \\n\u0026#34;, fname);\t//char  printf(\u0026#34;%s \\n\u0026#34;, fname);\t//string  printf(\u0026#34;%o \\n\u0026#34;, num);\t//octal  printf(\u0026#34;%x \\n\u0026#34;, num);\t//hexadecimal  printf(\u0026#34;%% \\n\u0026#34;, num);\t//for % itself   A decimal point in a constant indicates that it is a floating point e.g. 5 is integer, 5.0 is float.  printf(\u0026#34;%d \\n\u0026#34;, num);\t// integer has 6 digits width  printf(\u0026#34;%f \\n\u0026#34;, num);\t// integer has 6 digits width  printf(\u0026#34;%6d \\n\u0026#34;, );\t// integer has 6 digits width  printf(\u0026#34;%.3f\\n\u0026#34;, );\t// float can have any width integer part but decimal part has a limit of 3 digits \tprintf(\u0026#34;%.0f\\n\u0026#34;, );\t//supresses printing of the decimal point and the fractional part  printf(\u0026#34;%3.2f\\n\u0026#34;, );\t// atleast 3 wide, 2 after decimal point  The width in the integer part does not actually play a part as evident from below.\n#include\u0026lt;stdio.h\u0026gt; int main() { float n = 656.56789; int m = 251; printf(\u0026#34;%2.3f\\n\u0026#34;, n); printf(\u0026#34;%2d\\n\u0026#34;, m); printf(\u0026#34;%.0f\\n\u0026#34;, n); return 0; } Output: 656.568\t//rounded off to only 3 decimal places \t251\t//no effect \t657\t//whole decimal part rounded off with no digit left after decimal  Symbolic Constants  #define name replacement-text\n#define LOWER 0 #define UPPER 300 #define STEP 20  // We can now proceed to use the above defined constants throughout the program as it is.  // They are written in uppercase to distinguish them from variables.  Character input and output - getchar() and putchar() - Standard library provides them to read/write just one character at a time.  c = getchar();\t//reads the next character from text stream and return its value  putchar(c);\t//prints a character each time it is called   End Of File (EOF) - EOF is just a symbolic constant stored in \u0026lt;stdio.h\u0026gt; with some integer value that we don\u0026rsquo;t need to know. Whenever a file ends it returns a value that cannot be confused with any character\u0026rsquo;s integer value, that value is EOF.\n  Precedence of != is higher than =.\n  Expressions can be evaluated inside the loop condition.\n  #include\u0026lt;stdio.h\u0026gt; main(){ int c; while((c = getchar()) != EOF)\t//getchar() call is perfectly fine here \tputchar(c); }  Assignment  nl = nw = nc = 0; //above expression is evaluated as follows  (nl = (nw = (nc = 0)));  Functions - Declaration (Prototype), Definition, Call.  int func(int n, int m);\t//Declaration  or int func(int , int);\t//also valid  int func(int n, int m)\t//formal paramters (parameters) { //function statements  return expression;\t//zero implies normal termination, otherwise unusual or errorneous termination } main() { func(x,y);\t//actual parameters (arguments) }   Functions are always CALLED BY VALUE in C. We can be assured that the variables are always local to a called routine.\n  Character arrays are called Strings, they are terminated by a '\\0' character which may not be the part of our actual string but is very much a part of the character array. Besides this they work just like an integer array.\n  char str[4] = \u0026#34;abhi\u0026#34;;\t//this will lead to error that the string is too long beacuse we need one element (last element) of a character array for \u0026#39;\\0\u0026#39; character  External Variables and Scope - Local variables are called automatic variables because they are used automatically whenever we\u0026rsquo;re inside the scope/function. Global variables are called external variables and they must be defined exactly once outside any functions.  When using external variables before even defining them in the souce file we might have to declare them using - extern keyword.\nint foo() { extern int num; //other statements } int num = 2;\t//external variable  main() { foo(); } Note that the external variables are also there when we don\u0026rsquo;t need them, so we must avoid using them too much.\n"
},
{
	"uri": "https://hashdefine.netlify.app/linux-and-tools/shell-scripting/",
	"title": "Shell Scripting",
	"tags": [],
	"description": "",
	"content": "Lorem Ipsum.\n"
},
{
	"uri": "https://hashdefine.netlify.app/rdbms/postgresql/",
	"title": "PostgreSQL",
	"tags": [],
	"description": "",
	"content": "Lorem Ipsum.\n"
},
{
	"uri": "https://hashdefine.netlify.app/python/adv/",
	"title": "Advanced",
	"tags": [],
	"description": "",
	"content": "\u0026#39;\u0026#39;\u0026#39; Iterable Iterator Generator Closures Decorator Property RegEx \u0026#39;\u0026#39;\u0026#39; # Iterable -\u0026gt; objects that implement __iter__ and __next__.The function range() returns an iterator and for loop performs next() on it automatically. # Python offers a fundamental abstraction called the Iterable. # An iterable is an object that can be treated as a sequence. # The object returned by the range function, is an iterable. filled_dict = {\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3} our_iterable = filled_dict.keys() print(our_iterable) # =\u0026gt; dict_keys([\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;]). This is an object that implements our Iterable interface. # We can loop over it. for i in our_iterable: print(i) # Prints one, two, three # However we cannot address elements by index. our_iterable[1] # Raises a TypeError # An iterable is an object that knows how to create an iterator. our_iterator = iter(our_iterable) # Our iterator is an object that can remember the state as we traverse through it. # We get the next object with \u0026#34;next()\u0026#34;. First object too by next() initially. print(next(our_iterator)) # =\u0026gt; \u0026#34;one\u0026#34; #alternate syntax print(our_iterator.__next__())\t# =\u0026gt; \u0026#34;one\u0026#34; # It maintains state as we iterate. next(our_iterator) # =\u0026gt; \u0026#34;two\u0026#34; next(our_iterator) # =\u0026gt; \u0026#34;three\u0026#34; # After the iterator has returned all of its data, it raises a StopIteration exception next(our_iterator) # Raises StopIteration # We can also loop over it, in fact, \u0026#34;for\u0026#34; does this implicitly! our_iterator = iter(our_iterable) for i in our_iterator: print(i) # Prints one, two, three # You can grab all the elements of an iterable or iterator by calling list() on it. list(our_iterable) # =\u0026gt; Returns [\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;, \u0026#34;three\u0026#34;] list(our_iterator) # =\u0026gt; Returns [] because state is saved #We can also create our own iterator using classes that implement __iter__ and __next__ class TopTen: def __init__(self): self.num = 1 def __iter__(self): return self def __next__(self): if self.num \u0026lt;= 10:\t#always specify end val = self.num self.num += 1\t#increment by 1 return val else: raise StopIteration\t#raise exception or else None is traversed after 10 values = TopTen() print(next(values))\t# =\u0026gt; 1 # print(values.__next__()) for i in values: print(i) \u0026#39;\u0026#39;\u0026#39; 1 2 3 4 5 6 7 8 9 10 \u0026#39;\u0026#39;\u0026#39; # Generators = Functions that create iterators, they create __iter__ and __next__ implicitly # If a function contains at least one yield statement (it may contain other yield or return statements), it becomes a generator function. Both yield and return will return some value from a function. # yield = Local variables and theirs states are remembered between successive calls unlike return. def my_gen(): n = 1 print(\u0026#39;This is printed first\u0026#39;) # Generator function contains yield statements yield n n += 1 print(\u0026#39;This is printed second\u0026#39;) yield n n += 1 print(\u0026#39;This is printed at last\u0026#39;) yield n \u0026#39;\u0026#39;\u0026#39; \u0026gt;\u0026gt;\u0026gt; # It returns an object but does not start execution immediately. \u0026gt;\u0026gt;\u0026gt; a = my_gen() \u0026gt;\u0026gt;\u0026gt; # We can iterate through the items using next(). \u0026gt;\u0026gt;\u0026gt; next(a) This is printed first 1 \u0026gt;\u0026gt;\u0026gt; # Once the function yields, the function is paused and the control is transferred to the caller. \u0026gt;\u0026gt;\u0026gt; # Local variables and theirs states are remembered between successive calls. \u0026gt;\u0026gt;\u0026gt; next(a) This is printed second 2 \u0026gt;\u0026gt;\u0026gt; next(a) This is printed at last 3 \u0026gt;\u0026gt;\u0026gt; # Finally, when the function terminates, StopIteration is raised automatically on further calls. \u0026gt;\u0026gt;\u0026gt; next(a) Traceback (most recent call last): ... StopIteration \u0026gt;\u0026gt;\u0026gt; next(a) Traceback (most recent call last): ... StopIteration \u0026#39;\u0026#39;\u0026#39; # Closure = The data from the enclosing function gets binded to the inner function and persists even when outer function goes out of scope. # The criteria that must be met to create closure in Python are summarized in the following points. # 1. We must have a nested function (function inside a function). # 2. The nested function must refer to a value defined in the enclosing function. # 3. The enclosing function must return the nested function. def print_msg(msg): # This is the outer enclosing function def printer(): # This is the nested function print(msg) return printer # returns the nested function, not \u0026#34;printer(msg)\u0026#34; call # Now let\u0026#39;s try calling this function. # Output: Hello another = print_msg(\u0026#34;Hello\u0026#34;)\t# req. to store in another var, since we return a function another() # Decorator = A decorator function takes in a function as argument, adds some functionality and returns it. Uses closures ofcourse. # @ symbol to specify decorators, syntactic sugar @make_pretty\tdef ordinary(): print(\u0026#34;I am ordinary\u0026#34;) # above is equivalent to def ordinary(): print(\u0026#34;I am ordinary\u0026#34;) ordinary = make_pretty(ordinary) # Property # RegEx (Regular Expressions) # https://www.programiz.com/python-programming/regex "
},
{
	"uri": "https://hashdefine.netlify.app/maths/gcd-adv/",
	"title": "GCD and LCM Advanced",
	"tags": [],
	"description": "",
	"content": "Reducing Fractions  n\tn / gcd(n, d)\r--- =\u0026gt; Reduced Fraction =\u0026gt; ---------------\rd\td / gcd(n, d)\rGCD and LCM of fractions \tGCD (all numerators)\rGCD = -------------------------\rLCM (all denominators)\rLCM (all numerators)\rLCM = -------------------------\rGCD (all denominators)\rLCM of factorial and its neighbors LCM (n-1)!, n!, and (n+1)! is (n+1)!\nGCD and LCM follow Distributive Property gcd(a, lcm(b, c)) = lcm(gcd(a, b), gcd(a, c)) lcm(a, gcd(b, c)) = gcd(lcm(a, b), lcm(a, c)).\rGCD is distributive with other functions too We can have out own function f(n) and gcd will be distributive over it and vice-versa.\ngcd(f(n, x), f(n ,y)) = f(n, gcd(x, y))\rf(gcd(n, x), gcd(n ,y)) = gcd(n, f(x, y))\rProblem Link: https://www.geeksforgeeks.org/gcd-two-numbers-formed-n-repeating-x-y-times/\nStein\u0026rsquo;s Algorithm Time = O(n*n), where n is the number of bits in the larger of the two numbers.\nAlso called Binary GCD algorithm, is used to find gcd based on Euclidean Algorithm in an optimizaed way by avoiding any arithmetical operations and with just bitwise operations.\nLink: https://www.geeksforgeeks.org/steins-algorithm-for-finding-gcd/ Code: https://github.com/abhishekarya1/GfG-Codes/blob/master/Mathematical/GCD%20and%20LCM/gcd_steins_algo.cc\nGCD of floating point numbers Challenges\n % operator doesn\u0026rsquo;t work with floating point numbers in C/C++ They never become 0 as they are highly precise  double floatGCD(double a, double b) { if(fabs(b) \u0026lt; 0.001)\t//never reaches 0 but less than 0.001 will do \treturn a; return floatGCD(b, a - floor(a/b) * b);\t//or use: fmod(a, b) } GCD of elements in a given range GCD of consecutive numbers is 1, and GCD of any number with 1 is 1 itself. When we find GCD(n, n+1) in the range n to m, the full ranges' GCD becomes 1.\nint rangeGCD(int start, int end) { if(start == end) return start; return 1; } Array and GCD Problems Largest Subset with GCD 1 If at any point in traversal gcd = 1, then full array is the largest subset as it will also have gcd = 1.\nint largestSubset(int *arr, int n) {\tint curGCD = arr[0]; for(int i = 1; i \u0026lt; n; i++) { if(__gcd(curGCD, arr[i]) == 1) return n; } return 0; } Minimum steps to come back to starting point in a circular tour Link: https://www.geeksforgeeks.org/minimum-steps-to-come-back-to-origin-in-a-circular-tour/\nIf we jump m places in one step and there are a total of n slots in circle, then steps required to return to same place are: n / gcd(n, m)\n"
},
{
	"uri": "https://hashdefine.netlify.app/c++-language-specifics/",
	"title": "C++ Language Specifics",
	"tags": [],
	"description": "",
	"content": "C++ CP A collection of useful tips and tricks to use in C++ for CP.\n"
},
{
	"uri": "https://hashdefine.netlify.app/c/gfg-c/string_functions/",
	"title": "Character and String Functions",
	"tags": [],
	"description": "",
	"content": "Some Character Functions from \u0026lt;ctype.h\u0026gt; Mostly, internally, the ASCII value of the character is passed as argument and returns int other than zero if true, else return 0.\n  isprint() - Printable character is not a control character, they can be seen on screen\n  iscntrl() - Control character like \u0026lsquo;\\n\u0026rsquo; and \u0026lsquo;\\r\u0026rsquo;\n  islower() - Check lower-case\n  isupper() - Check uper-case\n  isgraph() - Graphic character other than space\n  ispunct() - Punctuation character\n  isdigit() - Numeric character\n  isalpha() - Alphabet character\n  toupper() - Converts character to upper case\n  tolower() - Converts character to upper case\n  \u0026lt;math.h\u0026gt; Library Fucntions Link: https://www.geeksforgeeks.org/c-library-math-h-functions/\nSome misc functions  rand() and srand() - \u0026lt;stdlib.h\u0026gt; time() and difftime() - \u0026lt;time.h\u0026gt;  Some String Function - \u0026lt;string.h\u0026gt;  strcat() - Concatenate strlen() - Length strcmp(left, right) - Compare and return +ve value if character at left string is greater in ASCII value than character in right string, else -ve if otherwise. strdup() - Duplicate strndup() - Duplicate till nthposition strrev() - Reverse strcpy() - Copy strspn() - https://www.geeksforgeeks.org/strspn-function-c/  "
},
{
	"uri": "https://hashdefine.netlify.app/c/c-dennis-ritchie/2019-01-22-c-programming-chapter-2/",
	"title": "Types, Operators, and Expressions ",
	"tags": [],
	"description": "",
	"content": "Variables  The first haracter must be a letter. Underscore(_) is a letter. Library functions have variable names that start with an underescore. Uppercase and lowercase letters are distinct, X is not the same as x.  Data Type and Sizes    Data type Keyword Size (in Bytes) Range     Character char 1    Integer int 2 -32768 to +32767   Single-precision floating point float 4 10-38to 10+38   Double-precision floating point double 8     Qualifiers can also be applied to these data types.\n  signed and unsigned applies to int and char data types.\n  int will be automatically assumed for unspecified.\n  Examples -\nsigned s; unsigned u; long l; long long ll; short int n; long int m; //the word int can be omitted -  short n; long m; A compiler is free to choose any size for these.\n  RULE - short and int must be atleast 16 bits, long must be atleast 32 bits, and short must not be larger than int whch must not be larger than long.\n  unsigned variables store zero and positive values only. signed stores both. Ex - if char is 8 bits, unsigned will store from 0 to 255 and signed from -128 to 127.\n  Constants  Integer constant - 1234 long - 123l or 123L or an integer too big to fit into int will be taken as long unsigned - 123u or 123U unsigned long - 123ul or 123UL Floating-point constant - 1234.0, their type is double unless suffixed with f/F (float) or l/L (long double) Octal - leading 0 on an integer - 012 Hexadecimal - leading 0x on an integer - 0x12  Octal and Hex constants may be followed by U or L suffix to make them unsigned or long respectively. 0xFUL // this is a unsigned long hex with value 15 in decimal  Character constant - written within single quotes. Ex - \u0026lsquo;A\u0026rsquo;, \u0026lsquo;b\u0026rsquo;, etc\u0026hellip;  \u0026#39;\\0\u0026#39; has an ASCII value of 0. \u0026#39;0\u0026#39; has an ASCII value of 48 which is unrelated to zero.  Escape Sequences  \u0026#39;\\013\u0026#39; - Octal Number \u0026#39;\\xAF\u0026#39; - Hex Number    Escape Sequence Function     \\n Newline character   \\t Horizontal tab character   \\v Vertical tab character   \\b Backspace character   \\f Formfeed   \\a Alert (bell) character   \\r Carrige return   ' Single quote   \u0026quot; Double quotes   \\\\ Backslash itself   ? Question mark   \\0oo Octal number   \\xhh Hex number    A character constant \u0026#39;a\u0026#39; is not the same as \u0026#34;a\u0026#34;, the former has an integer value internally and the latter is delimited by a null character (\u0026#39;\\0\u0026#39;) character. Constant Expression - #define MAX int p = MAX + 1; //These are evaluated at the compile-time.  Enumeration Constant - An enumeration is a list of constant integer values.  #include\u0026lt;stdio.h\u0026gt; int main() { enum my {hs, ho};\t//By default, first name in an enum has value = 0, second one has value = 1 and so on... \tprintf(\u0026#34;%d\\t\u0026#34;, he); printf(\u0026#34;%d\u0026#34;, ho); return 0; }\tOUTPUT: 0\t1 If not all values are specified, unspecified values continue the progression from the last specified value.\n#include\u0026lt;stdio.h\u0026gt; int main() { enum my {JAN = 23, FEB, MAR, APR, MAY}; printf(\u0026#34;%d\\t\u0026#34;, JAN); printf(\u0026#34;%d\\t\u0026#34;, FEB); printf(\u0026#34;%d\\t\u0026#34;, MAR); printf(\u0026#34;%d\\t\u0026#34;, APR); printf(\u0026#34;%d\\t\u0026#34;, MAY); return 0; } OUTPUT: 23\t23\t25\t26\t27 Names in an enumeration must be distinct, values may not be so.\nDeclarations  Global/External and static variables are initialized to 0 by default. Local/Automatic variables for which there is no initializer have undefined (i.e. garbage) values. const - It is used to indicate that the variable\u0026rsquo;s value cannot be changed now.  const int p = 5; //OR int func(const ch[]);\t//ch\u0026#39;s values cannot be changed by func() Operators Arithmetic Operators    Binary Arithmetic Operators Unary Arithmetic Operators     + +   - -   *    /    %      % operator cannot be applied to float or double.  Relational Operators    Relational Operators     \u0026gt;   \u0026lt;   \u0026gt;=   \u0026lt;=   ==   !=     Relational operators have lower precendence than arithmetic oprators. So, i \u0026lt; lim-1 is taken as i \u0026lt; (lim-1). Precedence of != is higher than assignment =.  Logical Operators    Logical Operators     !   \u0026amp;\u0026amp;   |\\     Evaluated from left to right.  if(!valid)\t//if not valid  //OR  if(valid == 0)\t//if valid is false  Type Conversions When taking place implicitly, \u0026ldquo;narrower\u0026rdquo; type to a \u0026ldquo;wider\u0026rdquo; type is done. Ex - float to int.\n Can a char when resolved to an integer be negative?  No, C guarantees that any character is not negative. Yet, some arbitrary bit pattern stored in character variables may appear to be negative on some machines, yet positive on others. For portability, specify signed or unsigned if non-character data is to be stored in char variables.   If tere are no unsigned oprands involved, and either oprand is long, float, double, or long double, other is converted to the same type. And short and char are converted to int. When unsigned operands are involved comparison between signed and unsigned operands is machine-dependent.  Cast Operators - (type-name) expression Ex - (float) 4/2; (unsigned int) 4.3 - 2; Increment and Decrement Operators  i++ is equivalent to i = i + 1, and i-- is quivalent to i = i - 1. Prefix - ++i and Postfix - i++. ++i increments the value of i and then uses it, and i++ increments the value before using it. They can only be applied to variables. An expression like (i + j)++ is illegal. In a context where no value is stored, prefix and postfix are the same. Ex - when used as loop counters.  Bitwise Operators    Bitwise Operators     \u0026amp;   \\   ^   \u0026laquo;   \u0026raquo;   ~     Left Shifting  x \u0026lt;\u0026lt; 2 //shifts left by two positions (equivalent to multiplying by 4)  Right Shifting  Right shifting an unsigned bit fills vacated bits with 0-bits. Right shifting a signed bit fills vacated bits with sign bit \u0026ldquo;arithmetic shift\u0026rdquo;, or with 0-bits \u0026ldquo;logical shift\u0026rdquo;.    #include\u0026lt;stdio.h\u0026gt;\tint main() { int p = 3; printf(\u0026#34;%d\\n\u0026#34;, ~p); return 0; } OUTPUT: -4 Assignment Operators and Expressions i = i + 2; //can be written as  i += 2;\t//+= is an assignment operator  In assignment operation the type is the same as the left side operand.  #include\u0026lt;stdio.h\u0026gt;\tint main() { char p = \u0026#39;a\u0026#39;; int x; p += x; printf(\u0026#34;%d\\n\u0026#34;, sizeof(p)); return 0; } OUTPUT: 1 Conditional Expressions a \u0026gt; b? max=a : max=b; //can also be written as -  max = a \u0026gt; b? a : b; IMPORTANT NOTE - The conditional expression is indeed and expression. Type conversion rules apply here.\n// assume f is float and n is int  (n \u0026gt; 0)? f : n; //result will be float no matter if the condition is true or not. Precedence and Order of Evaluation  The precedence of Bitwise operators is below == and != operators.  //Be careful in -  if((x \u0026amp; MASK) == 0) ...  C does not specify the order in which the operands of an operator are evaluated.  x = f() + g();\t//not sure which ammong f() or g() is evaluated first  //AND  printf(\u0026#34;%sd %d\\n\u0026#34;, ++n, power(2, n));\t//Different compiler, different results, based on what is evaluated first  Don\u0026rsquo;t write any code that depends upon the order of evaluation. They are not covered in the standard.  a[i] = i++;\t//Subscript is the old value of i or new?  //Ans - Compilers can interpret it in different ways and generate different answers based on the interpretation. "
},
{
	"uri": "https://hashdefine.netlify.app/maths/primes/",
	"title": "Prime Numbers",
	"tags": [],
	"description": "",
	"content": "Properties, Conjectures and Theorems Definition: A prime number is a number greater than 1 that has exactly two positive integer divisors, 1 and itself.\n1 is neither a prime, nor a composite. 2 is the only even prime. Only consecutive primes are 2 and 3. Every prime number can represented in form of 6n±1 except 2 and 3, where n is natural number. There are infinitely many primes. Prime Number Theorem - The number of primes till n are approximately equal to n /ln (n) when n is large. Alternatively, the probability that a given, randomly chosen number n is prime is inversely proportional to its number of digits, or to the logarithm of n. Goldbach\u0026rsquo;s conjecture - Every even integer greater than 2 can be expressed as the sum of two primes. Lemoine\u0026rsquo;s conjecture - Any odd integer greater than 5 can be expressed as a sum of an odd prime and an even semiprime. Legendre’s Conjecture - It says that there is always one prime number between any two consecutive natural number\u0026rsquo;s (n = 1, 2, 3, 4, 5, …) square. Bertrand\u0026rsquo;s postulate - Bertrand\u0026rsquo;s postulate is a theorem stating that for any integer n \u0026gt; 3, there always exists at least one prime number p with n \u0026lt; p \u0026lt; 2n-2. GCD of 2 primes is always 1. Euclid\u0026rsquo;s lemma - If a prime p divides a * b, then, p divides at least one of a and b. For example, 2|(6*9) =\u0026gt; 2|6. This may or may not be true for any non-prime instead of p. Hardy-Ramanujan Theorem - The number of prime factors of n will approximately be log(log(n)) for most natural numbers n. Rosser\u0026rsquo;s Theorem - The nth prime number is greater than the product of n and natural logarithm of n for all n greater than 1. Mathematically, For n \u0026gt;= 1, if p is the nth prime number, then p \u0026gt; n * (ln n). Fermat\u0026rsquo;s Little Theorem Euclid Euler Theorem Ulam Spiral or Prime Spiral  Other interesting Numbers  Co-Primes - Two numbers, a and b are said to be co-prime iff gcd(a,b) = 1. Two conecutive numbers are always co-prime. Any prime number is co-prime with every other number.\n  Twin Prime - A twin prime is a prime number that is either 2 less or 2 more than another prime number—for example, either member of the twin prime pair (11, 13). In other words, a twin prime is a prime that has a prime gap of two.\n  Prime Triplet - Prime Triplet is a set of three prime numbers of the form (p, p+2, p+6) or (p, p+4, p+6).\n  Semiprime - A semiprime number is a natural number that is a product of two prime numbers. Semiprimes include the squares of prime numbers. Because there are infinitely many prime numbers, there are also infinitely many semiprimes. Ex - 4, 6, 9, 10, 14, 15\u0026hellip;\n  Mersenne Primes - A Mersenne prime is a prime that can be expressed as 2p-1, where p is a prime number. They are extremely rare. Note that having the form of 2p-1 does not guarantee that the number is prime. Ex - 211-1 is not a prime. The largest known prime is a Mersenne Prime discovered using Lucas-Lehmer Series.\n  Emirps - An emirp (prime spelled backwards) is a prime number that results in a different prime when its decimal digits are reversed. This definition excludes the related palindromic primes. The term reversible prime may be used to mean the same as emirp, but may also, ambiguously, include the palindromic primes. Ex - 13, 17, 31, 37, 71, 73, 79, 97, 107, 113, \u0026hellip;\n  Special Primes - A prime number is said to be Special prime number if it can be expressed as the sum of three integer numbers: two neighboring prime numbers and 1. For example, 19 = 7 + 11 + 1, or 13 = 5 + 7 + 1.\n  Left and Right Truncatable Prime - If we keep on removing a digit from left or right, the number still remains a prime. Ex - 317.\n  Super Primes - also known as higher order primes are the subsequence of prime numbers that occupy prime-numbered positions within the sequence of all prime numbers. First few Super-Primes are 3, 5, 11 and 17. Since, 3 occupies the 2nd position and so on\u0026hellip;\n  Palindromic Primes - sometimes called a palprime is a prime number that is also a palindromic number. Ex - 2, 3, 5, 7, 11\u0026hellip;\n  Sophie Germain Prime - A prime number p is called a sophie prime number if 2p+1 is also a prime number. The number 2p+1 is called a safe prime. For example 11 is a prime number and 11*2 + 1 = 23 is also a prime number so, 11 is sophie germain prime number.\n  Almost Prime - A k-Almost Prime Number is a number having exactly k prime factors (not necessary distinct) For example, 2, 3, 5, 7, 11 ….(in fact all prime numbers) are 1-Almost Prime Numbers as they have only 1 prime factors (which is themselves). 4, 6, 9…. are 2-Almost Prime Numbers as they have exactly 2 prime factors (4 = 2*2, 6 = 2*3, 9 = 3*3) Similarly 32 is a 5-Almost Prime Number (32 = 2*2*2*2*2) and so is 72 (2*2*2*3*3).\n  Pernicious Number - A pernicious number is a positive integer which has prime number of ones in its binary representation. The first pernicious number is 3 since 3 = (0011)(in binary representation) and 1 + 1 = 2, which is a prime.\n  Twisted Prime - If a prime\u0026rsquo;s reverse is also a prime number. Ex - 31 and 13.\n  Balanced Prime - If a prime is equal to the (sum of its neighbours) / 2. Ex - 5, 53, 157, 173, \u0026hellip;\n  Sexy Prime - In mathematics, Sexy Primes are prime numbers that differ from each other by six. For example, the numbers 5 and 11 are both sexy primes, because they differ by 6. For a prime p, if p + 2 or p + 4 (where p is the lower prime) is also prime.\n  Pierpont Prime - A Pierpont Prime is a prime number of the form p = 2l.3k+ 1 (having factors 2 and 3 only + 1). First few Pierpont prime numbers are 2, 3, 5, 7, 13, 17, 19, 37, 73, 97, 109, …\n  Newman–Shanks–Williams Prime\n  Fermat Numbers - A number of the form 2x+ 1 (where x \u0026gt; 0) is prime if and only if x is a power of 2, i.e., x = 2n. So overall number becomes 22n+ 1. The first few Fermat numbers are 3, 5, 17, 257, 65537, 4294967297, \u0026hellip; An important thing to note is a number of this is not always prime.\n  Circular Prime - A prime number is a Circular Prime Number if all of its possible rotations are itself prime numbers.\n  Permutable Prime - A Permutable prime number is that number which after switching the position of digits through any permutation is also prime. Some of the permutable prime numbers are 2, 3, 5, 7, 11, etc.\n  Primality Tests 1. School Method Uses the fact that a composite number must have atleast one prime factor till sqrt(n) (obviously).\nLink: https://www.geeksforgeeks.org/primality-test-set-1-introduction-and-school-method/\nTime = O(√n)\n//School Method. Time = O(sqrt(n)) bool isPrime(int n) { if(n \u0026lt;= 1) return false; for(int i = 2; i*i \u0026lt;= n; i++)\t//better than using sqrt() \t{ if(n % i == 0) return false; } return true; } 1.1 Optimized School Method Time = O(√n)\nOptimization: We can check only odd numbers after 2 in the range 3 to sqrt(n).\nbool isPrime(int n) { // check if n is a multiple of 2  if (n % 2 == 0) return false; // if not, then just check the odds  for (int i = 3; i * i \u0026lt;= n; i += 2) if (n % i == 0) return false; return true; } Optimization: We can check only numbers of the form 6k±1 in the range 2 to sqrt(n).\nbool isPrimeOptimized(int n) { if(n \u0026lt;= 1) return false; if(n \u0026lt;= 3) return true; //remove multiples of 2 and 3 \tif(n % 2 == 0 || n % 3 == 0) return false; //from 5 check all multiples of the form 6k±1 (prime factors only) \tfor (int i = 5; i*i \u0026lt;= n; i += 6) { if(n % i == 0 \u0026amp;\u0026amp; n % (i+2) == 0) return false; } return true; } 2. Fermat\u0026rsquo;s Method Probabilistic test based on Fermat\u0026rsquo;s Little Theorem. Carmichael numbers are composite numbers which fail this test. Carmichael numbers are also called Fermat pseudoprimes.\nLink: https://www.geeksforgeeks.org/primality-test-set-2-fermet-method/\nIf p is a prime number, then for every a, 1 \u0026lt; a \u0026lt; p-1,\nap-1≡ 1 (mod p) OR ap-1 % p = 1\n3. Miller-Rabin Test This method is a probabilistic method (Like Fermat), but it generally preferred over Fermat’s method.\nLink: https://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/\n4. Solovay-Strassen Test Link: https://www.geeksforgeeks.org/primality-test-set-4-solovay-strassen/\n5. Lucas Primality Test Link: https://www.geeksforgeeks.org/lucas-primality-test/\n6. Lucas-Lehmer Series Link: https://www.geeksforgeeks.org/primality-test-set-5using-lucas-lehmer-series/\n7. AKS Primality Test Galactic Algorithm\nLink: https://www.geeksforgeeks.org/aks-primality-test/\n8. Wilson\u0026rsquo;s Theorem Link: https://www.geeksforgeeks.org/wilsons-theorem/ Link: https://www.geeksforgeeks.org/implementation-of-wilson-primality-test/\n9. Vantieghems Theorem for Primality Test Checks primes only till 11.\nLink: https://www.geeksforgeeks.org/vantieghems-theorem-primality-test/\n10. Lehmann\u0026rsquo;s Primality Test Link: https://www.geeksforgeeks.org/lehmanns-primality-test/\nFind all primes upto N (Sieves) Sieve of Eratosthenes Time = O(n*log(log(n)))\nComplexity Analysis: https://www.geeksforgeeks.org/how-is-the-time-complexity-of-sieve-of-eratosthenes-is-nloglogn/\nAlgorithm:  Create a list of numbers from 1 to n (size = n+1), and mark all as 1/true, mark 1 as 0  Start from 2 and,  Check if 1, if it is then mark all its multiples from i*i till n as 0  Repeat this while i \u0026lt;= sqrt(n)  void primeSieve(int n) { vector\u0026lt;int\u0026gt; s(n + 1, 1);\t//seive size = n+1, default all to 1 \ts[0] = s[1] = 0; for (int i = 2; i * i \u0026lt;= n; i++) { if (s[i] == 1) for (int j = i * i; j \u0026lt;= n; j += i) s[j] = 0; } for (int i = 0; i \u0026lt; s.size(); i++)\t//display \tif (s[i] == 1) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } Sieve of Eratosthenes in 0(n) time complexity Link: https://www.geeksforgeeks.org/sieve-eratosthenes-0n-time-complexity/\nSieve Of Sundaram Time = O(n log n) (Slower than linear Eratosthenes)\nAlgorithm: SOS can find all primes upto 2*n+2 for a given n.  Calculate newN = (n-1)/2, Make a sieve of size nNew+1 and mark all in sieve as false,  Mark all numbers of the form i + j + 2ij as true where 1 \u0026lt;= i \u0026lt;= j,  Print 2, Remaining primes are of the form 2i + 1 where i is index of NOT (false) marked numbers. So print 2*i + 1 for all i such that sieve[i] is false.  bool sieveSundaram(int n) { int nNew = (n - 1) / 2; bool s[nNew + 1]; memset(s, false, sizeof(s)); // Main logic of Sundaram. Mark all numbers of the \t// form i + j + 2*i*j as true where 1 \u0026lt;= i \u0026lt;= j \tfor (int i = 1; i \u0026lt;= nNew; i++) for (int j = i; (i + j + 2 * i * j) \u0026lt;= nNew; j++) s[i + j + 2 * i * j] = true; // Print 2 \tif (n \u0026gt; 2) cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // Print other primes. Remaining primes are of the form \t// 2*i + 1 such that marked[i] is false. \tfor (int i = 1; i \u0026lt;= nNew; i++) if (s[i] == false) cout \u0026lt;\u0026lt; 2 * i + 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;; return 0; } Goldbach\u0026rsquo;s Conjecture and Applications //Loop for checking and printing all prime sum pairs for (int i = 2; i \u0026lt;= n/2; ++i) { if(isPrime(i) \u0026amp;\u0026amp; isPrime(n - i))\t// if(s[i] \u0026amp;\u0026amp; s[n-i]) \t{ cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; (n - i); } } Application  Express even number as sum of two primes (Direct application)  Express odd number as sum of atmost three primes  If N can be expressed as sum of four primes  If N can be written as sum of K prime numbers  References  https://www.geeksforgeeks.org/mathematical-algorithms/mathematical-algorithms-prime-numbers-primality-tests/  https://procoderforu.com/prime-numbers Brilliant Wiki i. Prime Numbers ii. Infinitely Many Primes iii. Distribution of Primes iv. Mersenne Prime Theorems and Conjectures involving prime numbers  "
},
{
	"uri": "https://hashdefine.netlify.app/competitive-programming/",
	"title": "Competitive Programming",
	"tags": [],
	"description": "",
	"content": "Competitive Programming in C++ Addictive and fun.\nReferences Competitive Programming 3 by Steven Halim Competitive Programmer’s Handbook by Antti Laaksonen\n"
},
{
	"uri": "https://hashdefine.netlify.app/c/gfg-c/stdio/",
	"title": "Some &lt;stdio.h&gt; I/O Functions",
	"tags": [],
	"description": "",
	"content": "Basic \u0026lt;stdio.h\u0026gt; I/O Functions Formatted I/O int printf(const char *format, ...); int fprintf(FILE *stream, const char *format, ...); int sprintf (char *str, const char *format, ...); printf() family returns negative value if an output error or an encoding error. int scanf (const char *format, ...); int fscanf (FILE *stream, const char *format, ...); int sscanf (const char *str, const char *format, ...); scanf() family returns EOF if input failure occurs before the first receiving argument was assigned. Unformatted I/O char * gets (char *);\t//returns NULL pointer if error char * fgets (char *, int, FILE *); //returns NULL if error int puts (const char *);\t// returns non-negative no. if success, else EOF int fputs (const char *, FILE *); int getc (FILE *);\t// returns EOF when end of file or fails int fgetc (FILE *);\tint putc (int, FILE *); int fputc (int, FILE *); int getchar (void);\t// a.k.a fgetchar int putchar (int);\t// a.k.a fputchar int ungetc (int, FILE *); int feof(FILE *); // returns non-zero value on end of file, else 0 int fflush(FILE *); // returns 0 if success, otherwise EOF Non-Standard Functions - \u0026lt;conio.h\u0026gt; - [Header Native to MS-DOS] int getch();\t// returns character immediately w/o pressing “Enter” int getche(void); //same as getch(), returns the character twice "
},
{
	"uri": "https://hashdefine.netlify.app/c/gfg-c/struct_alignment/",
	"title": "Structure Alignment, Padding and Packing",
	"tags": [],
	"description": "",
	"content": "Structure Alignment, Padding, and Packing Link: https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/\nHow to avoid Structure Padding in C?  Using #pragma pack(1) idrective to force 1 Byte alignment We can also use the following (1 Byte alignment):  struct s { int i; char ch; double d; } __attribute__((packed)); Link: https://www.geeksforgeeks.org/how-to-avoid-structure-padding-in-c/\n"
},
{
	"uri": "https://hashdefine.netlify.app/c/c-dennis-ritchie/2019-01-22-c-programming-chapter-3/",
	"title": "Control Flow",
	"tags": [],
	"description": "",
	"content": "Statements and Blocks  An expression like i+2, i++, or printf(...) terminated by a ; becomes a statement in C. Braces { and } are used to group statements inside a compound statement or a block.  If-Else  In if-else the else part is optional. if checks the numeric value of an expression after evaluating it.  We might do -\nif(x)\t//non-zero value implicitly means true  //instead of  if(x != 0) Else-if  Multiple cases can be made using else-if. Additional case/error catching case can be a last else but it is optional.  Switch switch(expression) { case const-expr: statements case const-expr: statements default: statements }   Each case is labeled by integer-valued constants or constant expressions.\n  All cases must be different.\n  default case is optional.\n  IMPORTANT NOTE - Switch is fall through i.e. if we do not break the flow after a case, then it goes to the next case until it is stopped explicitly.\n  Several cases can be attached to a single action using this fall through property.\n  #include\u0026lt;stdio.h\u0026gt; int main() { char sec; scanf(\u0026#34;%s\u0026#34;, \u0026amp;sec); switch (sec) { case \u0026#39;a\u0026#39;: case \u0026#39;A\u0026#39;: case \u0026#39;b\u0026#39;: case \u0026#39;B\u0026#39;:\tcase \u0026#39;c\u0026#39;: case \u0026#39;C\u0026#39;:\tprintf(\u0026#34;Your class has 10 students.\u0026#34;); break; case \u0026#39;d\u0026#39;: case \u0026#39;D\u0026#39;:\tcase \u0026#39;e\u0026#39;: case \u0026#39;E\u0026#39;:\tprintf(\u0026#34;Your class has 11 students.\u0026#34;); break; default: printf(\u0026#34;Section not found.\u0026#34;); break; } return 0; } Loops - While and For  for and while loops are basically the same thing. All three - Initialization, Condition, and Update in a for loop are expressions and either of them can be omitted, but the semicolons must remain. Without the condition, for loop is infinite, even if we do not update. Multiple expression separated by comma are allowed in for loop.  for (int i = 0, j = 1; i \u0026lt; counti, j \u0026lt; countj; i++, j++) { /* code */ } Do-while  The condition check is at last so the body is executed atleast once. Braces around a single statement inside do block is optional but the while part can be mistaken for start of a while loop.  Break and Continue  break causes an exit from the innermost enclosing loop or switch. continue causes the next iteration of the loop to begin. A continue has no meaning in switch. IMPORTANT NOTE - A continue inside a switch inside a loop will cause the loop to jump to next iteration.  Goto and Labels  goto can jump to a label anywhere inside the same function. A label follows same naming conventions as that of variables.   "
},
{
	"uri": "https://hashdefine.netlify.app/maths/prime-factorization/",
	"title": "Prime Factorization and Divisors",
	"tags": [],
	"description": "",
	"content": "Recall: Fundamental Theorem Of Arithmetic\nImportant Points  The number of divisors is odd only for perfect square numbers. For the rest, the count is even. Use floor(sqrt(b)) - ceil(sqrt(a)) + 1 to calculate all perfect square numbers between a and b. Only a prime\u0026rsquo;s square has exactly 3 distinct factors i.e. 1, p, and p2. Power of a prime p in n! is given by Legendre\u0026rsquo;s Factorization of n! =\u0026gt; Power of p in n! = floor(n/p) + floor(n/p^2) + floor(n/p^3)..... till p^k \u0026gt; n. We can also calculate prime signature by finding out the exponents for each prime starting from 2 till p \u0026lt;= sqrt(n). Maximum occurring divisor in an interval is 2. Common divisors of two numbers are divisors of their GCD. Numbers which gets divided by both n and m upto q =\u0026gt; q / LCM(n, m), Numbers that get divided by n or m upto q =\u0026gt; (q / m + q / n - q / LCM(n, m)).  Finding Divisors Time = O(n)\nvoid printDivisors(int n) { for (int i = 1; i \u0026lt;= n; ++i)\t//till n \t{ if(n % i == 0) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } Efficient Approach: Suitable for finding sum of divisors (Aliquot Sum) as it does not print divisors in ascending order.\nTime = O(√n)\nvoid printDivisors(int n) { for (int i = 2; i*i \u0026lt;= n; ++i) //till sqrt(n)  { if(n % i == 0) { if(i*i == n) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; //for cases like, n=16, i and (n/i) both will be 4, we print only one  else cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; (n/i) \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } cout \u0026lt;\u0026lt; 1; //don\u0026#39;t forget the 1 } Aliquot Sum:\nint sumDiv(int n) { int sum = 0; for (int i = 2; i * i \u0026lt;= n; ++i) { if (n % i == 0) { if (i * i == n) sum += i; else sum += i + (n / i); } } return sum + 1; //as we started loop from 2 to avoid adding n itself } Sieve Based Method:\nTime = O(len) where len is the number of divisors, and\nSpace = O(MAX)\nconst int MAX = 1e5; vector\u0026lt;int\u0026gt; divisor[MAX + 1]; //array of vectors  void divisorSieve() { for (int i = 1; i \u0026lt;= MAX; i++) { for (int j = i; j \u0026lt;= MAX; j += i) { divisor[j].push_back(i); } } } void printDiv(int n) { for (int j = 0; j \u0026lt; divisor[n].size(); j++) { cout \u0026lt;\u0026lt; divisor[n][j] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } } int main() { int n = 10; //cin \u0026gt;\u0026gt; n;  divisorSieve(); printDiv(n); } Prime Factorization Time = O(√n)\nvoid printPrimeFactors(int n) { for(int i = 2; i*i \u0026lt;= n; i++) { while(n % i == 0) //removing every i from n  { cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; n /= i; } } if(n \u0026gt; 1) cout \u0026lt;\u0026lt; n; //the largest factor is prime itself } Using Sieve in O(log n) time Link: https://www.geeksforgeeks.org/prime-factorization-using-sieve-olog-n-multiple-queries/\nThe idea is to store the Smallest Prime Factor (SPF) for every number in a separate array. Then to calculate the prime factorization of the given number by dividing the given number repeatedly with its smallest prime factor till it becomes 1 and storing the quotient in every step. Those quotients are prime factors of the number.\n void factorSieve(int n, bool* s, int* spf) { s[0] = s[1] = false; spf[1] = 1; for (int i = 2; i \u0026lt;= n; i++) //notice i\u0026lt;=n  { if (s[i]) { spf[i] = i; //change  for (int j = i * i; j \u0026lt;= n; j += i) { s[j] = false; if (spf[j] == -1) spf[j] = i; //change  } } } } int main() { int n; cin \u0026gt;\u0026gt; n; bool s[n + 1]; int spf[n + 1]; memset(s, true, sizeof(s)); memset(spf, -1, sizeof(spf)); factorSieve(n, s, spf); //main logic  while (n != 1) { cout \u0026lt;\u0026lt; spf[n] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; n /= spf[n]; } return 0; } Pollard\u0026rsquo;s Rho Algorithm Link: https://www.geeksforgeeks.org/pollards-rho-algorithm-prime-factorization/\nApplications Prime Signature - https://mathworld.wolfram.com/PrimeSignature.html\nLink: https://www.handakafunda.com/number-system-concepts-for-cat-even-factors-odd-factors-sum-of-factors/\n All factors Even/Odd factors Sum of all factors Sum of Even/Odd factors Sum of all factors divisible by a number  Types of Numbers based on Divisors  Smith Numbers - Composite numbers with sum of prime factors equal to sum of digits in the number.  Sphenic Numbers - A positive integer having exactly three distinct prime factors. Alternatively, it is a product of exactly three distinct primes. Every sphenic number will have exactly 8 divisors.  Hoax Numbers - Similar to Smith numbers but here factors must be distinct. Some Hoax Numbers are Smith Numbers.  Frugal Number - A number whose number of digits is strictly greater than the number of digits in its prime factorization (including exponents). As apparent, a prime number cannot be frugal.  Blum Integer - It is a semiprime (product of two distinct primes) and those two prime factors are of the form 4t+3 where t is some integer.  Superperfect Number - A superperfect number is a positive integer which satisfies σ2(n) = σ(σ(n)) = 2*n, where σ is divisor summatory function.  Powerful Number - A number is said to be Powerful Number if for every prime factor p of it, p2 also divides it. For example, 36 is a powerful number as it is divisible by both 3 and square of 3 i.e, 9.  Deficient Number - Sum of divisors of the number is less than twice the value of the number n. The difference between these two values is called the deficiency.  Perfect Number - A number is a perfect number if is equal to sum of its proper divisors, that is, sum of its positive divisors excluding the number itself. Ex - 6 = 1 + 2 + 3. It is unknown whether there are any odd perfect numbers.  Betrothed numbers - Betrothed numbers are two positive numbers such that the sum of the proper divisors of either number is one more than (or one plus) the value of the other number. n1 = sum2 - 1 and n2 = sum1 - 1.  k-Rough Number or k-Jagged Number - A k-rough or k-jagged number is a number whose smallest prime factor is greater than or equal to the number ‘k’.  Amicable Pair - Two different numbers so related that the sum of the proper divisors of each is equal to the other number.  Friendly Pair - Two numbers whose ratio of sum of divisors and number itself is equal.  P-Smooth Number or P-friable Number - An integer is P–smooth number if the largest Prime factor of that number \u0026lt;= p. 1 is considered (by OEIS) as P–smooth number for any possible value of P because it does not have any prime factor.  k-Hyperperfect Number - A number n is called k-hyperperfect if: n = 1 + k ∑idi where all di are the proper divisors of n. Taking k = 1 will give us perfect numbers.   "
},
{
	"uri": "https://hashdefine.netlify.app/maths/",
	"title": "Maths for CP",
	"tags": [],
	"description": "",
	"content": "Maths for CP A collection of useful mathematical concepts and algorithms.\nReferences Articles \u0026amp; others "
},
{
	"uri": "https://hashdefine.netlify.app/c/gfg-c/functions_in_c/",
	"title": "Functions_in_C",
	"tags": [],
	"description": "",
	"content": "Calling functions before and after main() in GCC #include \u0026lt;stdio.h\u0026gt; void my_start_func(void) __attribute__ ((constructor)); void my_exit_func(void) __attribute__ ((destructor)); void my_start_func(void) {printf(\u0026#34;%s \u0026#34;, \u0026#34;Hello!\u0026#34;);} void my_exit_func(void) {printf(\u0026#34;%s\u0026#34;, \u0026#34;Arya\u0026#34;);} int main(void) { printf(\u0026#34;%s \u0026#34;, \u0026#34;Abhishek\u0026#34;); return 0; } // OUTPUT - Hello! Abhishek Arya Return type of any function used before declaration is assumed to be int and if it is int then the compilations is successful, else there is a type mismatch error , compilation fails. Also, is we do not mention the return type, it is assumed implicitly to be int.\n"
},
{
	"uri": "https://hashdefine.netlify.app/c/c-dennis-ritchie/2019-01-22-c-programming-chapter-4/",
	"title": "Functions and Program Structure",
	"tags": [],
	"description": "",
	"content": "Some advantages of using functions  Large computing tasks can be separated into smaller ones, so long as no function is split. Abstraction Easing the pain of making chanfges to code Source program can be stored across multiple files Code reusability  Basics of Functions return-type function-name(argument declarations) { declarations and statements //body }  If the return type is omitted during function declaration, it is assumed to be int. To return a value to the caller return is used.  return expression;\t//expression can be converted to the return type of the function if necessary  A function can return a \u0026ldquo;garbage value\u0026rdquo; or no value.  Functions Returning Non-integers double func(char arr[])\t//return type is double { //body  return sign; } //we can declare it in main() which is optional  main() { double func(arr[]);\t//same type here, otherwise meaningless answers } double func(char arr[])\t//return type is double { int sign; //body  return sign;\t//sign will be converted to double when returning value }   Statements following a return have no significance and are useless.\n  If a function uses no arguments, use void. Don\u0026rsquo;t leave it blank as parameter checking is turned off then and it is still there just for backwards compatibility.\n  int func(void) {...} External Variables  Variables \u0026ldquo;external\u0026rdquo; to any function a.k.a global variables. References to them are same no matter from where we\u0026rsquo;re accessing them. They have a scope that lasts for the lifetime of the whole program unlike automatic variables. No function can be defined inside any other function in C.  Scope Rules  Automatic variables have a scope that is limited to the function in which they are declared. External variables have program scope. Declaration announces the properties of a variable while a Definition also causes storage to be set aside.   A declaration can be done any number of times but definition only once. extern keyword is used to extend the visibility of variables/functions. Since functions are visible throughout the program by default. The use of extern is not needed in function declaration/definition. Its use is redundant. When extern is used with a variable, it’s only declared not defined. Ex - In extern int a;, a is not assigned any value and using it throws an error in compilation. As an exception, when an extern variable is declared with initialization, it is taken as the definition of the variable as well. Ex - extern int a = 4;  Program in different files:\nfile1 - int p = 4;\t// external variables are defined only once float q; file2 - extern int p;\t// declared wherever required extern float q; Command Line command to link both Files together - gcc file1.c file2.c\n// filename: \u0026#39;file1.c\u0026#39; int a; int main(void) { a = 2; } // filename: file2.c // When this file is linked with \u0026#39;file1.c\u0026#39;, functions of this file can access \u0026#39;a\u0026#39; extern int a; int myfun() { a = 2; } Header Files  After we divide the program into separate source files and using external variables from another file, we can store this file that contains external variables as a header file with an extension .h.  Each file that needs the calc.h header file has #include \u0026quot;calc.h\u0026quot; in the beginning as preprocessor directive.\n There is a tradeoff bwetween the desire that each file have access only to the information it needs for its job and the practical reality thaat it is harder to maintain more header files. Upto moderate program size, we should try to keep one header file.  Static Variables  Static variables are specified by specifier static. They are external variables that can only be accessed by the functions inside the same file and not by other functions not in the same file but are of the same program. Hence the names will also not conflict with other variables in differrent files.  static char buf[BUFSIZE]; static int bufp = 0; int getch(void) { ... } void ungetch(int c) { ... }  static can also be used for functions. the functions declared static will be invisible to the functions in the other files of the same program. static can also be used for local variables and are invisible to other functions but they remain (retain value) there even when we enter and leave functions (they are initialized the first time we enter a function, and never leave that value even if we try to change it) unlike automatic variables which are initialized everytime we call the function.  int main() { int x = 3; while (x \u0026gt; 0) { static int y = 5; // ignored after first iteration/initialization  y++; printf(\u0026#34;The value of y is %d\\n\u0026#34;, y); x--; } } OUTPUT: The value of y is 6 The value of y is 7 The value of y is 8\nHow are variables scoped in C – Static or Dynamic? In C, variables are always statically (or lexically) scoped i.e., binding of a variable can be determined by program text and is independent of the run-time function call stack.\nFor example, output for the below program is 0, i.e., the value returned by f() is not dependent on who is calling it. f() always returns the value of global variable x.\n# include \u0026lt;stdio.h\u0026gt;  int x = 0; int f() { return x; } int g() { int x = 1; return f(); } int main() { printf(\u0026#34;%d\u0026#34;, g()); printf(\u0026#34;\\n\u0026#34;); getchar(); } OUTPUT: 0\nRegister Variables  Variables specified using the register qualifier are an indication to the compiler that they will be used frequently and it should store them in registers which are only a few. Only automatic variables and formal parameters of a function can be made register variables. They are specified using register. Excess declarations with register are harmless, beacause it is then ignored. Further specifications vary across compilers. It is not possible to take the value of the register variable.  register int x; register char c; //functions  f(register unsigned m, register long n) { resigter int i; ... } Block Structure  Blocks are specified by { }, and variables declared and initialized inside a block remain automatic for only that block and there is no name clash with other variables outside the block.  int x; int y; func(int x) { int y; ... } In the above code, within the function func occurances of x refer to the parameter double x and all occurances outside func() refer to the external int x.\nInitialization  Variables are always initialized. External variables always with 0, and register and automatic variables with garbage values. While initializaing an external variable, the value needs to be a constant, which is not always the case with automatic variables.  Array Initialization int arr[] = {1, 2, 3, 4}; //size not specified, decide from the initializers = 4  int arr[4] = {1, 2, 3, 4, 5} //error  int arr[4] = {1, 2} //rest will be initialized with 0 weather arr[] is external/automatic, or register  char name[] = \u0026#34;two\u0026#34; //size = 4 /* OR */ char name[] = {\u0026#39;t\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;o\u0026#39;} Recursion  Automatic variables are initialized in each call again independent of previous set of values. No saving in space as stack is maintained for each call. Compact code better for recursively defined data structures like trees.  The C Preprocessor    Preprocessor Directives Function     #include \u0026ldquo;\u0026hellip;\u0026rdquo; or #include \u0026lt;\u0026hellip;\u0026gt; Header File Inclusion   #define Macros (#replacement-text, first ## second)   #if Conditional Preprocessing   #endif \u0026quot;   #elif \u0026quot;   #else \u0026quot;   #ifdef \u0026quot;   #ifndef \u0026quot;      File Inclusion - #inlcude \u0026quot;filename\u0026quot; or #include\u0026lt;filename\u0026gt;.\n #include is in itself a collection of many #define and an included file may contain further #include.    Macro Substitution - #define name replacement-text. Here, name cannot be inside quotes \u0026quot;...\u0026quot;.\n  #define forever for(;;) //infinite loop  #define max(a, b) ((a \u0026gt; b) ? (a) : (b))  #undef undefines macros  #undef func  The preprocessing operator \u0026lsquo;#\u0026rsquo; is used to convert a string argument into a string constant. Use # preceeding a replacement text to and it will be expanded as a quoted string \u0026quot;...\u0026quot;.  #define dprint(expr) printf(#expr \u0026#34; = %f\\n\u0026#34;, expr)  //example - dprint(x/y); //expanded as - printf(\u0026#34;x/y\u0026#34; \u0026#34; = /f\\n\u0026#34;, x/y); //strings will get concatenated as - printf(\u0026#34;x/y = %f\\n\u0026#34;, x/y);  If a macro has ## adjacent to arguments, in the expansion white spaces will be removed and arguments will be concatenated. Ex -  #define paste(first, second) first ## second  //call paste(name, 1); //result is - name1 Conditional Inclusion  Preprocessing can be controlled using these. We can check if a header file has been previously added by checking if the macros are defined using defined(name) function inside an #if-#endif block which returns 1 if defined, and 0 otherwise.  #if !defined(HDR) #define HDR  /* contents og hdr.h go here */ #endif  The #ifndef and #ifdef are specialized forms that test wheather a name is defined.  Above cde can be alternatively written as -\n#ifndef HDR #define HDR  /* contents og hdr.h go here */ #endif "
},
{
	"uri": "https://hashdefine.netlify.app/maths/fibonacci/",
	"title": "Fibonacci Numbers",
	"tags": [],
	"description": "",
	"content": "In mathematics, the Fibonacci numbers, commonly denoted Fn, form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F0= 0, F1= 1, and Fn= Fn-1+ Fn-2 for n \u0026gt; 1. Sequence = 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, \u0026hellip;\nNegative : The Fibonacci sequence also works below 0. It has alternating + and - accordingly. Ex - \u0026hellip;, −8, 5, −3, 2, −1, 1, 0. Which is basically, F−n= (−1)n+1* Fn for n \u0026gt; 1.\nThey also appear in biological settings, such as branching in trees, the arrangement of leaves on a stem, the fruit sprouts of a pineapple, the flowering of an artichoke, an uncurling fern, and the arrangement of a pine cone\u0026rsquo;s bracts.\nFinding nth Fibonacci Number Recursive Time = O(2^n)\nSpace = O(n)\nint fib(int n) { if(n == 0) return 0; if(n == 1) return 1; return fib(n - 1) + fib(n - 2); } Dynamic Programming Time = O(n)\nSpace = O(n)\nint fib(int n) { int arr[n + 1]; arr[0] = 0; arr[1] = 1; for(int i = 2; i \u0026lt;= n; i++) { arr[i] = arr[i - 1] + arr[i - 2]; } return arr[n]; } Space Optimized (Best) Time = O(n)\nSpace = O(1)\nint fib(int n) { if(n == 0) return 0; if(n == 1) return 1; int a = 0, b = 1, c; for(int i = 2; i \u0026lt;= n; i++) { c = a + b; a = b; b = c; } return c; } Using Power of Matrix Link: https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/\nUsing Binet\u0026rsquo;s Formula - O(1) Time = O(1)\nSpace = O(1)\nFormula: Fn is the nearest integer to ϕn/ √5.\nint fib(int n) { double phi = (1 + sqrt(5)) / 2; return round(pow(phi, n) / sqrt(5)); } Some Interesting Facts. Sum of Fibonacci numbers (Si) till nthFibonacci number (Fn) =\u0026gt; Sn= Fn+2- 1. To check if a number (n) is fibonacci or not - If either or both of 5n2+4 and 5n2-4 are perfect squares, then n is a fibonacci number. The series of last digits of numbers in Fibonacci sequence repeats with a cycle length of 60. Infact, Fibonacci sequence is periodic wrt Modulo. Application Cassini\u0026rsquo;s Identity -F(n-1) * F(n+1) – F(n) * F(n) = (-1)n. gcd(Fa, Fb) = Fgcd(a, b) Fibonorial - In mathematics, the Fibonorial n!F, also called the Fibonacci factorial, where n is a non-negative integer, is defined as the product of the first n positive Fibonacci numbers. Hosoya\u0026rsquo;s Triangle - Follows four seed relations - H(0, 0) = H(1, 0) = H(1, 1) = H(2, 1) = 1 and two recurrnce relations - H(n, j) = H(n - 1, j) + H(n - 2, j) and for the last element in current row H(n, j) = H(n - 1, j - 1) + H(n - 2, j - 2).  Zeckendorf\u0026rsquo;s Theorem \u0026amp; Fibonacci Coding Zeckendorf\u0026rsquo;s Theorem states that every positive integer can be written uniquely as a sum of distinct non-neighbouring Fibonacci numbers. Ex = 30 = 21 8 1, and 41 = 34 5 2.\nFibonacci coding is used in place of binary representation to represent positive numbers in data processing and communications. One important observation about this representation is, number of 1s in the Fibonacci representation tends to be much less than the number of 1s in the binary representation. Hence if in any application where it is more costly to store a 1 than to store a 0, it would make sense to use the fibonacci representation.\n//Greedy Algorithm to print Fibonacci representation of a number\r1) Let n be input number\r2) While n \u0026gt; 0\ra) Find the greatest Fibonacci Number smaller than n.\rLet this number be 'f'. Print 'f'.\rb) n = n - f int smallestFib(int n) { if (n == 0) return 0; if (n == 1) return 1; int a = 0, b = 1, c = 1; while (c \u0026lt;= n)\t//change \t{ c = a + b; a = b; b = c; } return a; } int main() { int n = 30; int i = 0; while (n \u0026gt; 0)\t//change \t{ i = smallestFib(n); cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34; \u0026#34;; n = n - i; } } Link#1 Link#2\nModular Nature of Fibonacci Fibonacci series is always periodic under modular representation i.e. F (mod m) will repeat after a certain period and the cycle will repeat too. This means we can find numbers diisible by a given number (m) at regular intervals in the Fibonacci sequence. Examples\nEven Fibonacci Numbers Using modular nature of the sequence, we can find period for numbers divisible by 2 (even numbers). That comes out to be 3 i.e. every third number in the Fibonacci sequence is divisible by 2. We can then come up with the recurrence relation to calculate ntheven Fibonacci number as:\nRecurrence for Even Fibonacci sequence is:\rEFn = 4(EFn-1) + (EFn-2)\rwith seed values,\rEF0 = 0 and EF1 = 2.\rEFn represents n'th term in Even Fibonacci sequence.\rThe period is calle the Pisano period.\nLeonardo Number Sequence of numbers given by the recurrence: The first few Leonardo Numbers are 1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, \u0026hellip;\nThe Leonardo numbers are related to the Fibonacci numbers by below relation: References  GeeksforGeeks Brilliant Wiki i. Fibonacci Sequence ii. Tribonacci Sequence  "
},
{
	"uri": "https://hashdefine.netlify.app/bit/",
	"title": "Bitwise Algorithms",
	"tags": [],
	"description": "",
	"content": "Bitwise Algorithms References "
},
{
	"uri": "https://hashdefine.netlify.app/c/gfg-c/pointer_in_c/",
	"title": "Pointers in C",
	"tags": [],
	"description": "",
	"content": "Void type, NULL and NULL Pointers Link: https://www.geeksforgeeks.org/few-bytes-on-null-pointer-in-c/\n  ((void *)0) is a macro defined in headers to be NULL.\n  sizeof(NULL) is a pointer type size.\n  NULL with pointers can be replaced with a 0.\n  NULL in printf is undefined behaviour in C standards.\n  Function Pointers Link: https://www.geeksforgeeks.org/function-pointer-in-c/\nHmmmmmmmm\u0026hellip;. Link: https://www.geeksforgeeks.org/an-uncommon-representation-of-array-elements/\n"
},
{
	"uri": "https://hashdefine.netlify.app/c/c-dennis-ritchie/2019-01-24-c-programming-chapter-5/",
	"title": "Pointers and Arrays",
	"tags": [],
	"description": "",
	"content": "Pointers and Addresses  Address Of Operator \u0026amp; can be applied to any memory object such as an array or a variable, not to any expression, constant, or register variable.  p = \u0026amp;c;\t//p stores address of c  //remember p is a pointer type variable  int *p; //pointer to an int, this says that value at *p is an int  Dereferencing or Indirection - * (value at) is the unary dereferencing operator and is used to access the value stored at a memory location.  *p = 0;\t//value at p = 0  Some Tips  \u0026amp; and * have higher precedence than arithmetic operators.    ++*ip; //increments value at ip  (*ip)++; //increments value at ip, parentheses are required here  iq = ip; //both are pointer variables to the same type, hence contents are copied into iq Pointers and Function Arguments  Call by Reference  swap(\u0026amp;a, \u0026amp;b); void swap(int *x, int *y) { int temp; temp = *x; *x = *y; *y = temp; } Pointers and Arrays  An array name is equivalent to the pointer to the first element. Ex - arr is same as \u0026amp;arr[0].  int a[10]; int *p = \u0026amp;a[0]; //then to reach the ith element we can do -  int x; x = *(p + i); //this all is same as doing -  x = p[i]; The assignment p = \u0026amp;a[0]; is the same as p = a.\nAn arary name is not a variable so expressions like - arr = p and arr++ are illegal.\n As Function Parameter -  func(int a[]) {...} //can also be written as -  func(int *a) {...} Address Arithmetic  Pointers can be added or subtracted with integer constants. Pointers from the same array (of the same type) can be subtracted. Pointers can be assigned to another pointer variable of the same kind. Pointers and integers are not interchangable with 0 being an execption.  int *p = 0; //valid  if(*p == 0) //valid //we can also use NULL defined in \u0026lt;stdio.h\u0026gt;  int *p = NULL;  Pointer Comparisons are valid if they belong to the same array.  p \u0026lt; q; //this is true if p referes to an earlier element in an array, p and q must belong to the same array  We cannot assign any pointer except void* to the pointer of another type without a cast.  Character Pointers and Functions char amessage[] = \u0026#34;now is the time\u0026#34;;\t/* an array */ char *pmessage = \u0026#34;now is the time\u0026#34;;\t/* a pointer */ Pointer Arrays; Pointers to Pointers  An array where each element is a pointer to another location.  Multi-dimensional Arrays int arr[10][10];\t//no. of rows = 10, no. of coloumns = 10  A multi-dimensional array can be thought of as an array where each element is in itself an array.   When passing a multi-dimensional array as function parameter -  int func(int arr[5][5]) { ... } //or  int func(int arr[][5]) { ... } //or  int func(int (*arr)[5]) { ... } Only the first dimension can be skipped.\nInitialization of Pointer Arrays Pointer arrays have to be initialized before they can be used.\nPointers vs. Multi-dimensional Arrays int a[10][20];\t//Multi-dimensional array having 10 pointers, each pointing to array of 20 elements  int *b[10];\t//pointer array of size 10, which can point anywhere  Pointer arrays have an advantage that they can point anywhere and there is no storage that must be set aside unlike multi-dimensional arrays. This saves space.  Command-line Arguments   In an environment using C, we can pass command-line arguments to a program when it begins executing.\n  int argc (argument count) and char *argv (argument vector) are used for this.\n  By convention, with argv[0] a program is called so argc = 1.\n  By convention, argv[argc] is a null pointer (=0).\n  echo hello, world is represented as -\n  Pointer to Functions  We can have pointer to functions and not use the signature with the pointer name as it is known throughout the program just like an array\u0026rsquo;s size.  int (*func)();\t//pointer to function returning an integer Complicated Declarations "
},
{
	"uri": "https://hashdefine.netlify.app/python/",
	"title": "Python Notes",
	"tags": [],
	"description": "",
	"content": "Learning Python \u0026gt;\u0026gt;\u0026gt; import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren\u0026#39;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you\u0026#39;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it\u0026#39;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let\u0026#39;s do more of those! References "
},
{
	"uri": "https://hashdefine.netlify.app/maths/divisibility/",
	"title": "Divisibility",
	"tags": [],
	"description": "",
	"content": "Divisibility Rules  2n, 5n, and 10n- Check if the last n digits are divisible. 3 and 9 - Check if digital sum is divisible. 6 - Check if number is divisible by both 2 and 3. 7 - Subtract twice the last digit from the remaining number and check divisibility again. Another method is triplet method (make triplets from right and do alternate +/- and check the result for divisibility by 7 again\u0026hellip; this is useful for very large numbers). 11 - If, sum of all digits at odd position - sum of all digits at even position is 0, then number is divisible by 11. 12 - Check if number is divisible by both 3 and 4\t.  Forming Divisibility Rules Composites - A number is divisible by a given divisor if it is divisible by the highest power of each of its prime factors. For example, to determine divisibility by 36, check divisibility by 4 and by 9. Note that checking 3 and 12, or 2 and 18, would not be sufficient.\nPrimes - We can form divisibility rules for primes \u0026gt;=13 by the following method.\nSuppose we want to find divisibility rule for 13, then we form equation as: 3x + 1 = 13, solving for x gives us x = 4 and we must multiply x with unit digit and sum to the remaining number and check divisibility again by 13.\nSuppose we want to find divisibility rule for 17, then we form equation as: 7x + 1 = 17, solving for x gives us x = 16/7 (floor of it is 2) and we must multiply x with unit digit and subtract from the remaining number and check divisibility again by 17.\nProgramming Problems and Solutions  Sum of all numbers divisible by n in range [L-R] - Sum all till R, and sum all till L-1 and subtract to get sum between [L-R].  Link\n//Formula\rsum = n + 2n + 3n + 4n + 5n ...\rsum =\u0026gt; n (1 + 2 + 3 + 4 + 5 ...)\rsum =\u0026gt; (n/2) * (n(n+1)/2) sumR = (n / 2) * (R/n) * ((R/n)+1)\rsumL as (n / 2) * ((L-1)/n) * ((L-1/n)+1)\r   References  https://en.wikipedia.org/wiki/Divisibility_rule D!NG - Divisibility Rules Brilliant Wiki i. Divisibility Rules ii. Proof Of Divisibility Rules  "
},
{
	"uri": "https://hashdefine.netlify.app/maths/modular-arithmetic/",
	"title": "Modular Arithmetic",
	"tags": [],
	"description": "",
	"content": "Remainders and % Operator In Maths:\n15 mod 7 = 1\r12 mod 5 = 2\r16 mod 4 = 0\r2 mod 6 = 2\r-1 mod 5 = -1 =\u0026gt; 4\t//do 1 mod 5 and add negative sign\r-15 mod 7 = -1 =\u0026gt; 6\r-12 mod 5 = -2 =\u0026gt; 3\r12 mod -5 = 2 =\u0026gt; -3\r16 mod -4 = 0\rIn Programming:\n If x completely divides y, the result of the expression y % x is 0. If y is not completely divisible by x, then the result will be the remainder in the range [1, x-1]. If x is 0, then division by zero is a compile-time error.  Restrictions in C/C++:\n The % operator cannot be applied to floating-point numbers i.e float, double, or long double. It leads to compile-time error. Since C++11, the modulus operator used with negative operands and give predictable result: x % y always returns results with the sign of x.  Operations on Modulo 1. (a + b) % c = ( ( a % c ) + ( b % c ) ) % c 2. (a * b) % c = ( ( a % c ) * ( b % c ) ) % c 3. (a – b) % c = ( ( a % c ) – ( b % c ) ) % c 4. (a / b ) % c = ( ( a % c ) / ( b % c ) ) % c (Not Distributive)\nNegative Remainders with Subtraction: We have to be careful with identity 3 as it can give negative value as result of modulo. Two fixes are -\nint ans = (a - b) % mod; if(ans \u0026lt; 0) ans += mod; int ans = ((a - b) % mod + mod) % mod;\t//slower than previous way as it increases mod operations Modulo Division Identity: (a / b) % m = ( ( a % m ) * ( 1/b ) % m ) % m. Finding modulo for division is not always possible.\nModulo Exponentiation Fixing Overflows with Modulo  Commonly used number is 109+7 or 1e9+7.  Gotcha!!\nlong long ans; ans = (a * b) % n; //a and b are huge numbers The above solution may lead to overflow as we multipled them and even when we're not storing them in variable ans before the modulo, they are still huge for intermediate value to be stored temporarily for performing modulo operation by the machine. Fix -\nlong long ans; ans = ( (a % n) * (b % n) ) % n; Congruence if (a mod n) = (b mod n), then\ra ≡ b (mod n)\rSome Observations regaarding a ≡ b (mod n):\r1. a = k * n + b //b need not be the remainder of a/n\r2. (a - b) is a multiple of n\rCongruence modulo is an equivalence relation for (mod C): It is reflexive, symmetric, and transitive.\nReflexive: A ≡ A (mod N)\rSymmetric: if A ≡ B (mod N) then B ≡ A (mod N)\rTransitive: if A ≡ B (mod N) and B ≡ C (mod N) then A ≡ C (mod N)\rReferences  https://brilliant.org/number-theory  https://www.geeksforgeeks.org/modular-arithmetic  "
},
{
	"uri": "https://hashdefine.netlify.app/c/gfg-c/behaviour_in_c/",
	"title": "Undefined, Unspecified, and Implementation-Defined Behavior in C",
	"tags": [],
	"description": "",
	"content": "Undefined Behavior {MOST DANGEROUS -:- BE AWARE -:- NEVER USE}\n  Undefined behavior refers to a statement made in a standard specification that a particular behavior is not defined by a standard, i.e, in C. Ex - Dividing by 0.\n  Some Other Examples:\n  int a;\t// a\u0026#39;s value can be anything (undefined) int arr[10]; arr[22] = 45;\t// compiler interprets as okay but undefined int *ptr;\t// pointer with a random address (undefined)  In the standard, it is explicitly stated that what all things are undefined. There are often diagnostic messages or warnings when we try and use undefined things in programs. Undefined behavior is mostly apparent during runtime when it\u0026rsquo;s the most dangerous. It often leads to \u0026ldquo;Programmer surprises\u0026rdquo;. The programmer is responsible for using the undefined things and must avoid them at all costs.  Unspecified Behavior  Unspecified behavior means that a standard has chosen, for whatever reason, to not define how a particular behavior \u0026ldquo;behaves\u0026rdquo;. This is often because different vendors have chosen to implement a behavior in different ways in well-established products. A range of all possible behaviors might be documented in the standard. Even the vendor is not required to always mention it explicitly (document it).  // Order of function parameter evaluation  int func (a++, a--, a + 5, a - 2); Implementation-defined Behavior  Dependent upon the vendor and it will change on different environments. Portable code should not rely on these. Explicit documentation of these features must be provided by the vendor.  int a;\tsizeof(a); char a;\tsizeof(a); double a;\tsizeof(a); long a;\tsizeof(a); // int can be 2 Bytes or 4 Bytes depending upon the machine and the environment // NULL pointer value can be implemented at the lower-level as -  ((void *)0)\t// in GCC TL;DR The undefined stuff is accepted as undefined by the standard, there is no fixed outcome. e.g. Dividing by 0. We may follow all the rules of the language and standard but still stumble upon unspecified stuff which does not lead to any specific outcome but many unintended ones are possible. Implementation-defined stuff is explicitly mentioned in the documentation of the environment in which we\u0026rsquo;re working, it varies from machine to machine and hamperes the portability of our program.\nReferences   Link: https://www.quora.com/What-is-the-difference-between-undefined-unspecified-and-implementation-defined-behavior\n  Link: https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior\n  Link: https://www.youtube.com/watch?v=Pl88WRJ-6l0\n  "
},
{
	"uri": "https://hashdefine.netlify.app/c/c-dennis-ritchie/2019-01-26-c-programming-chapter-6/",
	"title": "Structures",
	"tags": [],
	"description": "",
	"content": "Definition A structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling.\nBasics   A point is nothing but a pair of coordinates and a collection of points makes a rectangle.\n  struct keyword is used.\n  struct point { int x;\tint y;\t//members }; An optional name called a structure tag may follow the word struct.\nstruct point { int x; int y; } x , y, z;  We can also declare struct type variables.  struct point pt;\t//pt\u0026#39;s type is struct point  //initialization can be done by  struct point pt = { 320, 200 };  Accessing Members of a Structure - structure-name . member  struct point pt; int a = pt.x; int b = pt.y;  Structures can be nested as -  struct rect { struct point pt1; struct point pt2; }; //we can declare screen as  struct rect screen; //then  screen.pt1.x; Structures and Functions   The only legal operations on structures are -\n Copying it Assigning to it Taking its address (\u0026amp;) Accessing its members (.)    Structure parameters are passed by value.\n  We can pass a pointer to a structure.\n  struct point *pp; struct point origin; *pp = \u0026amp;origin; //to access elements  (*pp).x;  Shorthand Notation - If pp is a pointer to a structure, then  // instead of writing this  (*pp).x; // we can access members like this  pp -\u0026gt; x;  Precedence of -\u0026gt; operator is the Highest.  struct point { int x; char *str; } *p; ++ p -\u0026gt; x; // this increments x, not p  * p -\u0026gt; str; // this accesses location popinted to by str Arrays of Structures  Each element of array is a structure.  struct key { int count; char *word; } keytab[NKEYS];  Initialization -  Pointers to Structures  A function can return a pointer to a struct.  struct key *binsearch(int x, int y);  Don\u0026rsquo;t assume that the size of a structure is the sum of sizes of its members.  struct { char c; int i; };\t//its size can be 8, not 5 sizeof() returns the exact value.\nSelf-referential Structures  Used in recursively defined data structures like Trees.  struct node { int value; struct node *left; struct node *right;\t//referring to self } Table Lookup   When a line like #define IN 1 is encountered, the name IN and the replacement text 1 are stored in a table. Later, when the name IN appears in a statement like state = IN; it must be replaced by 1.\n  There are two routines that manipulate the names and replacement texts. install(s,t) records the name s and the replacement text t in a table; s and t are just character strings. lookup(s) searches for s in the table, and returns a pointer to the place where it was found, or NULL if it wasn\u0026rsquo;t there.\n  The algorithm is a hash-search - the incoming name is converted into a small non-negative integer, which is then used to index into an array of pointers. An array element points to the beginning of a linked list of blocks describing names that have that hash value. It is NULL if no names have hashed to that value.\n   A block in the list is a structure containing pointers to the name, the replacement text, and the next block in the list. A null next-pointer marks the end of the list.  struct nlist { /* table entry: */ struct nlist *next;\t/* next entry in chain */ char *name;\t/* defined name */ char *defn; /* replacement text */ }; Typedef  We can create a new name for a data type using typedef.  typedef int Length; In the program that follows, we can use Length in place of int as a new type.\nLength x, y;  typedef in C basically works as an alias.  typedef can be used to alias compound data types such as struct and union. typedef can be used to alias both compound data types and pointer to these compound types. typedef can be used to alias a function pointer. typedef can be used to alias an array.    Unions  A union is a variable that may hold multiple variables of any type and size.  union u_tag { int ival; float fval; char *sval; } u;   Accessing of members can be done as - union-name . member or union-pointer -\u0026gt; member.\n  The size of a union is big enough to hold the \u0026ldquo;widest\u0026rdquo; number.\n  Operations permitted are same as those of structures.\n  A union may only be initialized with a value of the type of its first member; thus union u described above can only be initialized with an integer value.\n  Bit-fields  A bit-field, or field for short, is a set of adjacent bits within a single implementation-defined storage unit that we will call a \u0026ldquo;word\u0026rdquo;.  struct { unsigned int is_keyword : 1; unsigned int is_extern : 1; unsigned int is_static : 1; } flags; The number following the colon represents the field width in bits.\n  Individual fields are referenced in the same way as other structure members: flags.is_keyword, flags.is_extern, etc.\n  Almost everything about fields is implementation-dependent.\n  "
},
{
	"uri": "https://hashdefine.netlify.app/flask/",
	"title": "Flask",
	"tags": [],
	"description": "",
	"content": "Flask Micro-Framework Working Notes\nReferences javaTpoint\nPacktPub Course\nOfficial Documentation\n"
},
{
	"uri": "https://hashdefine.netlify.app/c/c-dennis-ritchie/2019-01-27-c-programming-chapter-7/",
	"title": "Input and Output",
	"tags": [],
	"description": "",
	"content": "Introduction Input and output are not part of the C language itself. They are provided by the standard library.\nStandard Input and Output   int getchar(void) returns the next symbol from the input stream, or EOF whose value is typically -1.\n  The function int putchar(int) is used for output: putchar(c) puts the character c on the standard output, which is by default the screen. putchar returns the character written, or EOF if an error occurs.\n  Input Redirection - We can input from a file using the command-line \u0026lt;\n  prog \u0026lt; infile  Output Redirection - Output can be saved to a file using -  prog \u0026gt; outfile  Input can come from another program via a pipe mechanism: on some systems, the command line otherprog | prog runs the two programs otherprog and prog, and pipes the standard output of otherprog into the standard input for prog.  otherprog | prog Formatted Output - printf int printf(char *format, arg1, arg2, ...);   printf converts, formats, and prints its arguments on the standard output under control of the format. It returns the number of characters printed.\n  The format string contains two types of objects: ordinary characters, which are copied to the output stream, and conversion specifications, each of which causes conversion and printing of the next successive argument to printf. Each conversion specification begins with a % and ends with a conversion character (d, f, c, s, etc..).\n   In printing strings the following applies -  :%s: :hello, world:\t// normal :%10s: :hello, world:\t// atleast 10 characters to be printed :%.10s: :hello, wor:\t// atmost 10 characters to be printed :%-10s: :hello, world:\t// left alignment of printed characters :%.15s: :hello, world:\t// atmost 15 characters to be printed :%-15s:\t:hello, world :\t// atleast 15 characters to be printed, padding required on the right :%15.10s: : hello, wor:\t// atleast 15 places, and atmost 10 characters :%-15.10s: :hello, wor :\t// atleast 15 places, and atmost 10 characters, left aligned  The function sprintf does the same conversions as printf does, but stores the output in a string:  int sprintf(char *string, char *format, arg1, arg2, ...); sprintf formats the arguments in arg1, arg2, etc., according to format as before, but places the result in string instead of the standard output; string must be big enough to receive the result.\nFormatted Input - Scanf int scanf(char *format, ...);  scanf reads characters from the standard input, interprets them according to the specification in format, and stores the results through the remaining arguments. It returns as its value the number of successfully matched and assigned input items. This can be used to decide how many items were found. On the end of file, EOF is returned; note that this is different from 0, which means that the next input character does not match the first specification in the format string.  int sscanf(char *string, char *format, arg1, arg2, ...)  sscanf - It scans the string according to the format in format and stores the resulting values through arg1, arg2, etc. These arguments must be pointers.  int day, year; char monthname[20]; scanf(\u0026#34;%d %s %d\u0026#34;, \u0026amp;day, monthname, \u0026amp;year);\t//No \u0026amp; is used with monthname, since an array name is a pointer File Access FILE *fp; FILE *fopen(char *name, char *mode); This says that fp is a pointer to a FILE, and fopen returns a pointer to a FILE.\nfp = fopen(name, mode); The first argument of fopen is a character string containing the name of the file. The second argument is the mode, also a character string, which indicates how one intends to use the file. Allowable modes include read (r), write (w), and append (a).\nIf a file that does not exist is opened for writing or appending, it is created if possible. Opening an existing file for writing causes the old contents to be discarded, while opening for appending preserves them. Trying to read a file that does not exist is an error, and there may be other causes of error as well, like trying to read a file when you don\u0026rsquo;t have permission. If there is any error, fopen will return NULL.\n getc returns the next character from the stream referred to by fp; it returns EOF for end of file or error.  int getc(FILE *fp)  putc is an output function: putc writes the character c to the file fp and returns the character written, or EOF if an error occurs.  int putc(int c, FILE *fp)   When a C program is started, the operating system environment is responsible for opening three files and providing pointers for them. These files are the standard input, the standard output, and the standard error; the corresponding file pointers are called stdin, stdout, and stderr, and are declared in \u0026lt;stdio.h\u0026gt;. Normally stdin is connected to the keyboard and stdout and stderr are connected to the screen.\n  int fclose(FILE *fp) is the inverse of fopen, it breaks the connection between the file pointer and the external name that was established by fopen, freeing the file pointer for another file.\n  Error Handling - Stderr and Exit  The function ferror returns non-zero if an error occurred on the stream fp.  int ferror(FILE *fp)  The function feof(FILE *) is analogous to ferror; it returns non-zero if end of file has occurred on the specified file.  int feof(FILE *fp) Line Input and Output  fgets is similar to the getline function.  char *fgets(char *line, int maxline, FILE *fp)   fgets reads the next input line (including the newline) from file fp into the character array line; at most maxline-1 characters will be read. The resulting line is terminated with '\\0'. Normally fgets returns line; on end of file or error it returns NULL. (Our getline returns the line length, which is a more useful value; zero means end of file.)\n  fputs writes a line to a file.\n  int fputs(char *line, FILE *fp) It returns EOF if an error occurs, and non-negative otherwise.\n The library functions gets and puts are similar to fgets and fputs, but operate on stdin and stdout. Confusingly, gets deletes the terminating '\\n', and puts adds it.  Miscellaneous Functions String Operations - \u0026lt;string.h\u0026gt;  In the following, s and t are char *, and c and n are ints.     Function Use     strcat(s,t) concatenate t to end of s   strncat(s,t,n) concatenate n characters of t to end of s   strcmp(s,t) return negative, zero, or positive for s \u0026lt; t, s == t, s \u0026gt; t   strncmp(s,t,n) same as strcmp but only in first n characters   strcpy(s,t) copy t to s   strncpy(s,t,n) copy at most n characters of t to s   strlen(s) return length of s   strchr(s,c) return pointer to first c in s, or NULL if not present   strrchr(s,c) return pointer to last c in s, or NULL if not present    Character Class Testing and Conversion - \u0026lt;ctype.h\u0026gt;  In the following, c is an int that can be represented as an unsigned char or EOF. The function returns int.     Function Use     isalpha(c) non-zero if c is alphabetic, 0 if not   isupper(c) non-zero if c is upper case, 0 if not   islower(c) non-zero if c is lower case, 0 if not   isdigit(c) non-zero if c is digit, 0 if not   isalnum(c) non-zero if isalpha(c) or isdigit(c), 0 if not   isspace(c) non-zero if c is blank, tab, newline, return, formfeed, vertical tab   toupper(c) return c converted to upper case   tolower(c) return c converted to lower case    Ungetc int ungetc(int c, FILE *fp)  ungetc pushes the character c back onto file fp, and returns either c, or EOF for an error. Only one character of pushback is guaranteed per file. ungetc may be used with any of the input functions like scanf, getc, or getchar.  Command Execution  The function system(char *s) executes the command contained in the character string s, then resumes execution of the current program.  As a trivial example, on UNIX systems, the statement\nsystem(\u0026#34;date\u0026#34;); causes the program date to be run; it prints the date and time of day on the standard output. system returns a system-dependent integer status from the command executed.\nStorage Management  malloc  void *malloc(size_t n) returns a pointer to n bytes of uninitialized storage, or NULL if the request cannot be satisfied.\n calloc  void *calloc(size_t n, size_t size) returns a pointer to enough free space for an array of n objects of the specified size, or NULL if the request cannot be satisfied. The storage is initialized to zero.\n free  free(p) frees the space pointed to by p, where p was originally obtained by a call to malloc or calloc.\nMathematical Functions - \u0026lt;math.h\u0026gt;    Function Use     sin(x) sine of x, x in radians   cos(x) cosine of x, x in radians   atan2(y,x) arctangent of y/x, in radians   exp(x) exponential function ex   log(x) natural (base e) logarithm of x (x\u0026gt;0)   log10(x) common (base 10) logarithm of x (x\u0026gt;0)   pow(x,y) xy   sqrt(x) square root of x (x\u0026gt;0)   fabs(x) absolute value of x    Random Number generation The function rand() computes a sequence of pseudo-random integers in the range zero to RAND_MAX, which is defined in \u0026lt;stdlib.h\u0026gt;.\n"
},
{
	"uri": "https://hashdefine.netlify.app/git/",
	"title": "Git",
	"tags": [],
	"description": "",
	"content": "Git \u0026amp; GitHub Quick Jots\nReferences https://gitimmersion.com/\nhttps://learnxinyminutes.com/docs/git/\nCheatsheet :https://training.github.com/downloads/github-git-cheat-sheet/\nPractice: http://git-school.github.io/visualizing-git/\nhttps://www.packtpub.com/product/git-and-github-the-complete-git-and-github-course-video/9781800204003\n"
},
{
	"uri": "https://hashdefine.netlify.app/rdbms/",
	"title": "RDBMS",
	"tags": [],
	"description": "",
	"content": "RDBMS Relational DataBase Management System\nReferences MySQL https://www.mysqltutorial.org/\nPostgreSQL "
},
{
	"uri": "https://hashdefine.netlify.app/nosql/",
	"title": "NoSQL Databases",
	"tags": [],
	"description": "",
	"content": "NoSQL Databases A different approach for better scalability.\n"
},
{
	"uri": "https://hashdefine.netlify.app/regex/",
	"title": "Regex",
	"tags": [],
	"description": "",
	"content": "Regex Learning regex and solving problems from various sources.Why tho? Because this: Checkout Running notes and examples here.\n"
},
{
	"uri": "https://hashdefine.netlify.app/linux-and-tools/",
	"title": "Linux and Tools",
	"tags": [],
	"description": "",
	"content": "Lorem Ipsum.\n"
},
{
	"uri": "https://hashdefine.netlify.app/",
	"title": "#define HOME",
	"tags": [],
	"description": "",
	"content": "#define A collection of all my notes and elucidations by abhishek_arya.\n  Visit Blog   Email   "
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-18-const/",
	"title": "Const",
	"tags": [],
	"description": "",
	"content": "Constant Data Members Data Members declared with cont keyword cannot be re-initialised. They must be initialized once. They can be declared once and initialised once.\nconst int x; // Declaration\rx = 90; // Initialisation\rInitialisation List Any const data member must be initialised in Initialisation List.\nCar():name(NULL), year(1991)\r{\r}\rCar(int price, int m):price(p), model(m) // Memory allocated to variables before entering the body of the constructor\r{\r}\rConstant Functions Those functions that do not update data members of a class. They are basically there to identify themselves that they do not update any data members, so no need to debug them for data member related bugs.\nvoid start() const\r{\r// Body\r}\rConstant Parameter To declare a parameter as a constant for a function, they remain constant for that function throughout its scope.\nvoid print(const int n, char name)\r{\r// Body\r}\r// n cannot be changed throughout the scope of the print() function.\r"
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-18-constructors-destructors/",
	"title": "Constructors and Destructors",
	"tags": [],
	"description": "",
	"content": "Constructors Every class comes with four hidden functions.\n Default Constructor Parameterized Constructor Copy Constructors Destructor  Default Constructors  They have the same name as the class and do not have any return type. They are provided implicitly and they initialise with 0.  class me\r{\rme()\r{\r// they have nothing inside\r}\r}\rParameterized Constructors If we write something inside and parameterize it, then it is called parameterized constructor.\nclass me\r{\rpublic:\rint marks;\rint age;\rme(int m, int a) // Constructor with parameters\r{\rmarks = m; // Putting in values\rage = a;\r}\rvoid print()\r{\rcout \u0026lt;\u0026lt; marks \u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rcout\u0026lt;\u0026lt; age;\r}\r};\rint main()\r{\rme t(99, 19); // parameterized constructor call\rt.print();\r}\rCopy Constructors It is used to create a copy of given object of the same type.\nIt exists by default and we don\u0026rsquo;t need to create it explicitly.\n\rclass me\r{\rpublic:\rint marks;\rint age;\rme()\r{\r// Default Constructor\r}\rme(int m, int a) // Parameterized Constructor\r{\rmarks = m; // Putting in values\rage = a;\r}\rme(me \u0026amp;x) // Copy Constructor (parameter is another object from where to copy which is PASSED BY REFERENCE)\r{\rmarks = x.marks;\rage = x.age;\r}\rvoid print()\r{\rcout \u0026lt;\u0026lt; marks \u0026lt;\u0026lt;\u0026quot; \u0026quot;;\rcout\u0026lt;\u0026lt; age;\r}\r};\rint main()\r{\rme t(99, 19); // Parameterized Constructor call\rt.print();\rme m1(t); // Copy Constructor Call [create object m1 and, copy object t's values in object m1]\rme m1 = t; // Alternate Call Syntax for Copy Constructor\rm1.print();\r}\rShallow Copy and Deep Copy We don not need to assign the same array memory every time for our need, say, name. We can have char name[40] and store names in it, but sometimes names are shorter than 40 and a lot of space is wasted because for every name array is allocated.\nSolution - We can allocate space to array on demand, dynamically from the Heap.\nWhen pointers are copied from one object to another using Default Copy Constructor the address in the pointer remains the same and changes done to one will be reflected into the others too. This is a Shallow Copy.\nHence we need to dynamically allocate new pointers in our new object and copy data manually in our Copy Constructor to avoid this. This is a DeepCopy.\n#define LABEL(x, val) cout \u0026lt;\u0026lt; \u0026quot;Updated Value of \u0026quot; \u0026lt;\u0026lt; (#x) \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; (val)\\\r\u0026lt;\u0026lt; endl\rclass Person{\rint age;\rpublic:\rchar* name;\rPerson(int k, const char n[]){\rage = k;\rint len = strlen(n);\rname = new char[len]; // dynamic allocation\rstrcpy(name, n);\r}\rvoid print(){\rcout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot;:\u0026quot; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl;\r}\r};\rint main(){\rPerson P1(20, \u0026quot;Johnny\u0026quot;);\rP1.print(); // Johnny : 20\rPerson P2 = P1; // Person P2(P1); P2.initialiseWith(P1)\rP2.print(); //Johnny : 20\rP2.name[0] = 'T';\rLABEL(P2, P2.name); // Tohnny\rLABEL(P1, P1.name); // Tohnny // Shallow Copy\r}\rShallow Copy happened because the we copied pointer to array from P1 to P2, and when we changed in P2, changes were reflected in P1 too.\n  With default copy constructor only a Shallow Copy is created.\n  We can explicitly create copy constructor to create a Deep Copy.\n  To create a deep copy just create a new array for P2 using explicitly supplied copy constructor.\nPerson(const Person\u0026amp; p){ // Explicit Copy Constructor\rage = p.age;\rname = new char[strlen(p.name)]; // Deep Copy created\rstrcpy(name, p.name); // Array copied\r}\rint main(){\rPerson P1(20, \u0026quot;Johnny\u0026quot;);\rP1.print(); // Johnny : 20\rPerson P2 = P1; // Person P2(P1); P2.initialiseWith(P1)\rP2.print(); //Johnny : 20\rP2.name[0] = 'T';\rLABEL(P2, P2.name); // Tohnny\rLABEL(P1, P1.name); // Johnny }\rCopy Asignment Operator We can assign values from one constructor to another. It can called many times, unlike copy Constructor which is called only once when creating an object.\nCar c;\rCar d;\rd = c;\rd = e;\rd = r; // Copy Assignment Constructor\rBeware - Copy Assignment Constructor creates shallow copy, do not use it if you have any pointers among data members.\nDestructors Default Destructor - Destroys created objects as soon as the program [main() function] goes out of scope implicitly. It does not deletes dynamically allocated data members, for them we have to manually delete them using delete ptr.\n Same name as class name preceded by a tilde ~. Do not return anything and do not take any parameters. We only need to write it for deleting dynamically allocated data members. When a class contains a pointer to memory allocated in class, we should write a destructor to release memory before the class instance is destroyed. This must be done to avoid memory leak.  Car()\r{\rcout \u0026lt;\u0026lt; \u0026quot;Deleting...\u0026quot;;\rdelete [] name; // Deleting 'name' array\r}\rint main()\r{\rCar *DC = new Car(1991, \u0026quot;Audi\u0026quot;); // Dynamic Object will not be destroyed by default destructor\rdelete DC;\r}\r"
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-18-oops-in-c++/",
	"title": "Object-Oriented Programming in C++",
	"tags": [],
	"description": "",
	"content": "Goals Everything in the real-world has a name and a functionality associated with it. Ex - A name of an object is \u0026ldquo;Dog\u0026rdquo;, it can have various parameters like breed, length, height, or the functions it can perform like running, eating, sleeping.\nWhat we can do is that we can create objects of a Dog and then whenever we want to store different information about any Dog, we can use that object again and again.\nEverything that has an independent existence in real-life is called an Object, it can also be called as an Instance of a class.\nA Class is the blueprint for an object that tells the compiler how and what our object and its properties and functions are.\n// Define Blueprint\rclass Car\r{\rpublic:\rint price;\rint model_no;\t// Data Member\rbool isRunning();\t// Function\r};\rint main()\r{\rCar c;\t// To create object just like we declare a variable of a type\rcout \u0026lt;\u0026lt; sizeof(c); // c is an object of 8 bytes\rcout \u0026lt;\u0026lt; sizeof(Car); // 8 bytes because sizeof() returns size of the object when it'll be created\r// A class is just a piece of code and is nothing without its object\rCar R[100]; // Array of Cars\r}\rThe properties (variables) like name and size are called as Data Members.\nint num;\rchar name[20];\rThe functions and tasks associated are called Functions.\nint nRotations();\rbool isRunning();\rDot(.) Operator Used to access Data Members and Functions.\nCar c;\rc.name = \u0026quot;BMW\u0026quot;;\rc.model_no = 1991;\rc.isRunning();\rAccess Modifiers  private - By Default C++ has all data members and functions as Private. They cannot be accessed by functions not part of the class. public - They can be accessed anywhere.  class Pen\r{\rpublic:\rstring name;\rstring colour;\r}\rprotected  Getters and Setters Getters are used to get the value of a data member.\nSetters are used to set the value of a data member.\nclass Car\r{\rstring name; };\rint main()\r{\rCar c;\rc.name=\u0026quot;Audi\u0026quot;; // directly accessing a private data member not allowed\r}\rWe can use getters and setters to access and modify private data members as shown below.\nclass Car\r{\rprivate:\rint year;\rpublic:\rvoid setYear(int y)\t// Setter Function\r{\ryear=y;\r}\rint getYear()\t// Getter Function\r{\rreturn year;\r}\r};\rint main()\r{\rCar c;\rc.setYear(2006);\t// Setter Function Call\rcout \u0026lt;\u0026lt; c.getYear();\t// Getter Function Call\r}\rMemory allocation Every Object and Data Member gets allocated a space, but Functions have a common memory across all objects.\n"
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-18-vectors-and-generic/",
	"title": "STL - Vectors and Generic Programming",
	"tags": [],
	"description": "",
	"content": "Vectors They are data structures in C++ just like arrays but they have size that is capped only by the amount of space we can possibly allocate.\n Header files:  #include\u0026lt;vector\u0026gt;\r Declaration:  vector\u0026lt;int\u0026gt; v; // vector\u0026lt;data_type\u0026gt; name;\rAs Function Parameter Passed by Reference:\nint func(int n, vector\u0026lt;int\u0026gt; \u0026amp;v) { }\rBuilt in Functions  v.push_back(x) - Pushes the element(x) inside the vector. v.pop_back(x) - Pops the element(x) from the vector. v.reserve(100) - Reserves a vector space of 100. v.size() - Returns size of the vector.  For more functions, refer here.\nGeneric Programming in C++  Placeholders in templates get replaced by a data type.  Generic Data Types and Function Templates To declare a generic data type.\ntemplate\u0026lt;typename T\u0026gt; or template\u0026lt;class T\u0026gt;\r Usage:  #include\u0026lt;iostream\u0026gt;\rusing namespace std;\rtemplate \u0026lt;typename T\u0026gt;\rT bigger(T a, T b) // Generic Function with a generic Return Type\r{\rif(a \u0026gt; b) return a;\relse return b;\r}\rint main()\r{\rcout \u0026lt;\u0026lt; bigger(14.2,7.2);\r}\rOUTPUT : 14.2\r With Multiple Placeholders:  #include\u0026lt;iostream\u0026gt;\rusing namespace std;\rtemplate \u0026lt;typename X, typename Y\u0026gt;\rY bigger(X a, Y b) // Generic Function with a generic Return Type (X)\r{\rif(a \u0026gt; b) return a;\relse return b;\r}\rint main()\r{\rcout \u0026lt;\u0026lt; bigger(14.2,7);\r}\rOUTPUT : 14\rWe can also use the below syntax:\ntemplate\u0026lt;typename T\u0026gt;\rclass Vector{\rT arr[100];\r}\rclass Me{\rint roll_no;\rchar name[10];\r}\rint main(){\rVector\u0026lt;int\u0026gt; v1;\t// Associating Constructor of Class Vector and type int and Making the whole as another object (v1)\rVector\u0026lt;Me\u0026gt; v2;\t// Associating another class object (type) and making the whole as an object (v2)\rchar arr_char[] = {'a','b','c'};\rprint\u0026lt;char\u0026gt;(arr_char, 3);\rprint\u0026lt;char\u0026gt;(arr_char, 3, compareInt);\t// Function call for a specific data type specified by [function_name\u0026lt;data_type\u0026gt;(para,meter,s)]\r}\rLet\u0026rsquo;s see another example -\nclass Elephant{\rpublic:\rint wt;\rchar name[20];\r};\rtemplate\u0026lt;typename T, typename Y \u0026gt;\rvoid print(T arr[], int n, Y printCriteria){\t// Y is a function type\rfor(int i = 0; i \u0026lt; n; ++i){\rprintCriteria(arr[i]);\t// printMyElephant(arr[i])\r}\rcout \u0026lt;\u0026lt; endl;\r}\rvoid printMyElephant(Elephant E){\rcout \u0026lt;\u0026lt; E.wt \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; E.name \u0026lt;\u0026lt; endl;\r}\rint main(){\rElephant E[] = {\t// Array of objects\r{1600, \u0026quot;Hachi\u0026quot;},\r{1500, \u0026quot;Rocky\u0026quot;},\r{1000, \u0026quot;Jumbo\u0026quot;}\r};\rprint(E, 3, printMyElephant);\t// Passed whole function\r}\rIn the above example we created a function for comparing Elephants. Since our compiler didn\u0026rsquo;t know how to print Elephants, we passed that function to our generic function to print any values adding another parameter for it and the value in print() got bounded during compile-time to printMyElephant() that we passed in our call.\nClass Templates Since we can also pass into out Generic type the objects of class. We have to be careful as the algorithms that work flawlessly for data types might not work for an object. Ex - How do you compare two objects? What is the result of this? - Car c \u0026gt; Pen p;.\nWe need to build a Generic system that frees our algorithm from implementation and truly make us achieve generic nature across all types.\nclass VectorInt{\rint arr[100];\r};\rclass VectorChar{\rchar arr[100];\r};\rtemplate \u0026lt;typename T\u0026gt;\rclass Vector{ // Generic Class\rT arr[100]; // Array has elements of type T\r};\rclass Elephant{\rint wt;\rchar name[100];\r};\rint main(){\r// VectorInt vint; // container of ints (object)\r// VectorChar vchar; // container of chars (object)\rVector\u0026lt;int\u0026gt; v1;\rVector\u0026lt;char\u0026gt; v2; Vector\u0026lt;Elephant\u0026gt; v3; // Vector containing Elephant data type\r}\rMore here.\n"
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-18-strings/",
	"title": "STL - Strings",
	"tags": [],
	"description": "",
	"content": "Strings string is an in-built class in C++.\nstring name;\rstring s(\u0026quot;Abhishek\u0026quot;);\rstring s1 = \u0026quot;Abhishek\u0026quot;;\rstring s3;\rgetline(cin, s3);\rFor further info, refer here.\n"
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-10-bitwise-and-recursion/",
	"title": "Bitwise Operations and Recursion",
	"tags": [],
	"description": "",
	"content": "BITWISE Operator \u0026gt;\u0026gt; Right Shift Operator - results in 2^(number of times shifted)\r\u0026lt;\u0026lt; Left Shift Operator\r  Bitwise AND (\u0026amp;) yields an integer value. Bitwise OR (|) yields an integer value. Bitwise XOR (^) yields either 0 or 1. To identify if the last bit is SET(=1), AND(\u0026amp;) the number with 1.  Recursion int factorial(int n){\rif(n==0)\t// Base Case\r{\rreturn 1;\r}\rint smallFact = factorial(n-1);\t// Recurrence Relation\rFact = smallFact * n;\rreturn Fact;\r}\r"
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-09-pointers/",
	"title": "Pointers",
	"tags": [],
	"description": "",
	"content": "Address  There exists one more data type called as \u0026ldquo;Address Data Type\u0026rdquo; which is used to store data. It has certain limitations in arithmetic operations that can be done with it and it is often represented as a Hex value. It behaves much like a real-world address. Address of anything is basically its starting address location (address). e.g. Arrays, etc\u0026hellip;  Meaning and Syntax  int *ptr = \u0026amp;x; - This statement creates a variable named \u0026ldquo;ptr\u0026rdquo; that stores address (data type) of the integer variable \u0026lsquo;x\u0026rsquo; - ptr is also called a Pointer. The * operator is called a value at operator, and another operator \u0026amp; is called address of operator. The above statement is same as writing - int *ptr = \u0026amp;x; x here can contain any value e.g. x = 20; We refer to the address ptr and value at ptr by *ptr. There are two ways to define pointers, pick one ans follow throughout your program.  int* ptr = x;\t// Asterisk with data-type\rint *ptr = y;\t// Asterisk with pointer name\r int *ptr = x; or int *ptr = 10; will lead to compile-time error because we\u0026rsquo;re trying to assign integer value to a pointer data type.  #include\u0026lt;iostream\u0026gt;\rusing namespace std;\rint main()\r{\rint x = 10;\rint* ptr = \u0026amp;x;\rcout \u0026lt;\u0026lt; ptr;\t// will print address of x\rcout \u0026lt;\u0026lt; *ptr;\t// will print 10\r}\r DO NOT declare pointers (create pointers and leave them without initializing them). int *ptr; Doing this will lead to undefined behaviour as a garbage address value will be assigned to ptr and if it does not lie in our program\u0026rsquo;s allloted address space then the program will crash (Segmentation Fault). Segmentation Fault - Whenever we try to access an invalid or unavailable location. Contexts of the * symbol -  Declaration - int *ptr = \u0026amp;x; Dereferencing- int *ptr = \u0026amp;x; Multiplication - x * y   Only 0 or NULL can be typed as address for a pointer initialization.  Size of a Pointer A pointer is just another variable storing the address of others, so no matter what datatype it is pointing to, they are of same size - ALWAYS.\nPointer Arithmetic  Addition and Multiplication - Pointer addition is not valid as the result of the addition is an address that may or may not be valid (Implementation Defined). Division and Modulo - Not valid. Subtraction - ptr2 - ptr1 yields a result specifying how many elements can be accomodated between ptr2 and ptr1, hence only pointers of same data type can be substracted. Pointer added with and integer - ptr + 10 yields a result that is 10 elements further from the given address (initial value of ptr).  Pointers and Arrays  int arr[5] = {10, 20, 30, 40, 50};\rcout \u0026lt;\u0026lt; arr; // arr is address of array, first element address, note that how only the name is enough cout \u0026lt;\u0026lt; \u0026amp;arr[0]; // address of the first element of array\rcout \u0026lt;\u0026lt; \u0026amp;arr; // arr is address of ARRAY\rcout \u0026lt;\u0026lt; arr[0]; // arr[0]\rcout \u0026lt;\u0026lt; (\u0026amp;arr[3]) - (\u0026amp;arr[0]);\t// 2 = (Starting address of 3rd element - Starting address of 0th element)\rcout \u0026lt;\u0026lt; \u0026amp;arr[3] - \u0026amp;arr[1];\t// 1\rWhen refering to the array with its name only e.g. Arya insted of Arya[], we are implying that we want address of the array, which is nothing but the address of the first element itself. If we do cout \u0026lt;\u0026lt; Arya;, we\u0026rsquo;ll get the address value equal to cout \u0026lt;\u0026lt; Arya[0].\nPointers and Character Arrays  char carr[5] = \u0026quot;abcd\u0026quot;;\rcout \u0026lt;\u0026lt; carr;\t// abcd, will print everything from given address to '\\0'\rcout \u0026lt;\u0026lt; \u0026amp;carr[2];\t// c d\rcout \u0026lt;\u0026lt; carr[2];\t//\tc\rcout \u0026lt;\u0026lt; (int*)\u0026amp;carr[2];\t// some address of carr[2]\rcout \u0026lt;\u0026lt; \u0026amp;carr[3] - \u0026amp;carr[1];\t// 2\rNOTICE - cout in case \u0026amp;carr[2] that the output is c d, this is because cout\u0026lt;\u0026lt; is designed such that is prints values at addresses fed to it until a '\\0' is encountered. In print((int*)\u0026amp;carr[2]) the address get typecasted to a pointer type and hence converts to the address of the second element of the character array.\nPointers and Functions In the below code, the two function definitions are exactly the same, as implicitly, only a pointer to the array is passed to the function definition as they are always passed by reference.\nint func2(int* arr){\r}\rint func1(int arr[]){\r}\rPointer Arrays int (*ptr)[10] represents a pointer array of size 10.\n"
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-07-my-sublime-env/",
	"title": "My Sublime Environment for Coding",
	"tags": [],
	"description": "",
	"content": "Preliminaries  Download and copy /MinGW/bin path to the Environment Variables. Download Link - www.cb.lk/compile Setup Guide. Link - https://medium.com/@aggarwaldeepak/c-learning-environment-3df85a46784b  Sublime Packages Keyboard Shortcut: Ctrl+Shift+P -\u0026gt; Install Packages -\u0026gt; \u0026ldquo;Package Name\u0026rdquo;\n SublimeAStyleFormatter Terminal Wakatime  More Keyboard Shortcuts  For Building/Compiling: Ctrl+B For Powershell Terminal: Ctrl+Shift+T For Auto-formatting the code: Ctrl+Alt+F For New Tab: Ctrl+N For Closing Current Tab: Ctrl+W For Saving Current: Ctrl+S For Saving As.. Current: Ctrl+Shift+S For Switching Tabs: Ctrl + Tab For Scrolling Up/Down: Ctrl + Up/Down Key For Inserting HTML Tags: write tagname and then press Tab For Multiple Coloumns: Alt + Shift + number of coloumns (max. = 4, nos. after that for various display modes) Focus on Single Coloumn: Ctrl + number of coloumn Jump to the closing/opening braces of a block: Ctrl + M List all functions: Ctrl + R  Snippets in Sublime Tools -\u0026gt; Developer -\u0026gt; New Snippet\u0026hellip;\nLink:: https://www.quora.com/How-can-I-add-my-default-C-C++-code-in-Sublime-Text\n \u0026gt; cpp_default.sublime-snippet\r Input from an \u0026ldquo;input.txt\u0026rdquo; file directly in Sublime Tools -\u0026gt; Build System -\u0026gt; New Build System\u0026hellip; Link:: https://www.quora.com/Is-there-a-way-to-compile-and-run-C++-in-Sublime-Text\n\u0026gt; MyC++Build.sublime-bulid\r Build Systems Used to change with what compiler does sublime compile and other command-line options\nLink: https://www.thecrazyprogrammer.com/2017/04/how-to-run-c-and-c-program-in-sublime-text.html\nsubl - command line access  Open sublime just by typing subl in terminal and pressing Enter Create a new file by typing subl file_name.cc in terminal and pressing Enter  Open start menu,\n Type Edit environment variables Open the option Edit the system environment variables Click Environment variables\u0026hellip; button There you see two boxes, in System Variables box find path variable Click Edit a window pops up, click New Type the Directory path of your .exe or batch file ( Directory means exclude the file name from path) Click Ok on all open windows and restart your system restart the command prompt.  "
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-07-quick-jots/",
	"title": "Quick Jots",
	"tags": [],
	"description": "",
	"content": " The most significant dimension of an array is optional while defining a function with array as an argument.  int example(int arr[][3][3], int n) { }\t// Function Definition\r Short-circuit Evaluation  while(i \u0026lt; len \u0026amp;\u0026amp; arr[i] == 100)\t// if first condition is false, second is never evaluated\rwhile(i \u0026lt; len || arr[i] == 100)\t// if first condition is true, second is never evaluated\rwhile(i \u0026lt; len \u0026amp;\u0026amp; arr[i] == 100)\rwhile(arr[i] == 100 \u0026amp;\u0026amp; i \u0026lt; len) // both these statements are not equivalent as second returns a segmentation fault, because the first is evaluated first\t"
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-07-imp/",
	"title": "Important Points",
	"tags": [],
	"description": "",
	"content": " Arrays are always passed by reference, be it character array(string) in C++.  cin  cin ifnores whitespaces and reads only non-whitespace characters, cin reads from a file known as \u0026lsquo;stdin\u0026rsquo;\u0026ldquo;istream\u0026rdquo; and cin can be invalidated by supplying value of a type that is not expected, cin gets invalidated and never takes any input throughout the rest of the program.  return cin; //will return false if cin has been invalidated before\rWe can re-validate cin by cin.clear();.\n Enter or \u0026lsquo;\\n\u0026rsquo; is a valid character and is written into and read from the istream file just as other characters, but it is also a delimiter for cin and cin.getline().  cin.get()  it taks only one input at a time and that includes whitespaces.  cin.getline() char str[100];\rcin.getline(str,90,'$') //cin.getline(storage_string_name, max_size, 'delimiter_character')\t[max_size\u0026lt;str_size]\r Delimiter is not read by cin.getline(). By default delimiter is \u0026lsquo;\\n\u0026rsquo; aka newline character/Enter.  cin.getline(str,90); // default delimiter`\r cin.getline() will not ignore whitespaces and wil go onto read until delimiter, charaters from the file after the delimiter will not be read.  "
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-06-03-references/",
	"title": "Reference and Array Sorting Algorithms",
	"tags": [],
	"description": "",
	"content": "Pass by Reference void myswap(int \u0026amp;n1, int \u0026amp;n2) //formal parameters\t/*Called Function\tPass by Reference*/\r{\rint temp=n1;\rn1=n2;\rn2=temp;\r}\rint main()\t// Calling Function\r{\rint a,b;\rcin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b;\rmyswap(a,b);\t//arguments or actual parameters\t// Function call independent of pass method\rcout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;\u0026quot; \u0026quot;\u0026lt;\u0026lt;b;\r}\t  Pass by Value - New variables are created\t- Pass by Reference\t- New variables are not created, new names are given to the existing variables.   Algorithms 1. Sorting an Array\ra. Bubble Sort\rb. Insertion Sort\rc. Selection Sort "
},
{
	"uri": "https://hashdefine.netlify.app/c++/2018-07-08-all/",
	"title": "All Notes",
	"tags": [],
	"description": "",
	"content": "Links for all programming notes. [Day-] - Functions and Arrays\n[Day-] - Reference and Array Sorting Algorithms\n[PDF Download](/cb/Class 5 (as PDF).pdf)\n"
},
{
	"uri": "https://hashdefine.netlify.app/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://hashdefine.netlify.app/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": "Contributors Thanks to matcornic and all the contributors for the awesome learn theme.\nPackages and libraries  mermaid - generation of diagram and flowchart from text in a similar manner as markdown font awesome - the iconic font and CSS framework jQuery - The Write Less, Do More, JavaScript Library lunr - Lunr enables you to provide a great search experience without the need for external, server-side, search services\u0026hellip; horsey - Progressive and customizable autocomplete component clipboard.js - copy text to clipboard highlight.js - Javascript syntax highlighter modernizr - A JavaScript toolkit that allows web developers to use new CSS3 and HTML5 features while maintaining a fine level of control over browsers that don\u0026rsquo;t support  Tooling  Netlify - Continuous deployment and hosting of this site Hugo - This site is built with HUGO v0.48  "
},
{
	"uri": "https://hashdefine.netlify.app/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]